diff -ruN openssh-7.3p1/atomicio.c openssh-7.3p1.aros/atomicio.c
--- openssh-7.3p1/atomicio.c	2016-07-28 00:54:27.000000000 +0200
+++ openssh-7.3p1.aros/atomicio.c	2016-08-11 19:00:46.348967513 +0200
@@ -49,28 +49,29 @@
  * ensure all of data on socket comes through. f==read || f==vwrite
  */
 size_t
-atomicio6(ssize_t (*f) (int, void *, size_t), int fd, void *_s, size_t n,
-    int (*cb)(void *, size_t), void *cb_arg)
+_atomicio6(ssize_t (*f) (int, void *, size_t), int fd, void *_s, size_t n,
+    int (*cb)(void *, size_t), void *cb_arg, int isloc)
 {
 	char *s = _s;
 	size_t pos = 0;
 	ssize_t res;
-	struct pollfd pfd;
 
-#ifndef BROKEN_READ_COMPARISON
-	pfd.fd = fd;
-	pfd.events = f == read ? POLLIN : POLLOUT;
-#endif
 	while (n > pos) {
-		res = (f) (fd, s + pos, n - pos);
+
+		if (isloc) {
+			res = (f) (fd, s + pos, n - pos);
+		} else {
+			if (f == read)
+				res = recv (fd, s + pos, n - pos, 0);
+			if (f == vwrite)
+				res = send (fd, s + pos, n - pos, 0);
+		}
+
 		switch (res) {
 		case -1:
 			if (errno == EINTR)
 				continue;
 			if (errno == EAGAIN || errno == EWOULDBLOCK) {
-#ifndef BROKEN_READ_COMPARISON
-				(void)poll(&pfd, 1, -1);
-#endif
 				continue;
 			}
 			return 0;
@@ -89,9 +90,22 @@
 }
 
 size_t
-atomicio(ssize_t (*f) (int, void *, size_t), int fd, void *_s, size_t n)
+atomicio6(ssize_t (*f) (int, void *, size_t), int fd, void *_s, size_t n,
+    int (*cb)(void *, size_t), void *cb_arg)
+{
+	return _atomicio6(f, fd, _s, n, cb, cb_arg, 0);
+}
+
+size_t
+atomicio_loc(ssize_t (*f) (int, void *, size_t), int fd, void *_s, size_t n)
+{
+	return _atomicio6(f, fd, _s, n, NULL, NULL, 1);
+}
+
+size_t
+atomicio_net(ssize_t (*f) (int, void *, size_t), int fd, void *_s, size_t n)
 {
-	return atomicio6(f, fd, _s, n, NULL, NULL);
+	return _atomicio6(f, fd, _s, n, NULL, NULL, 0);
 }
 
 /*
@@ -105,7 +119,6 @@
 	size_t pos = 0, rem;
 	ssize_t res;
 	struct iovec iov_array[IOV_MAX], *iov = iov_array;
-	struct pollfd pfd;
 
 	if (iovcnt > IOV_MAX) {
 		errno = EINVAL;
@@ -114,10 +127,6 @@
 	/* Make a copy of the iov array because we may modify it below */
 	memcpy(iov, _iov, iovcnt * sizeof(*_iov));
 
-#ifndef BROKEN_READV_COMPARISON
-	pfd.fd = fd;
-	pfd.events = f == readv ? POLLIN : POLLOUT;
-#endif
 	for (; iovcnt > 0 && iov[0].iov_len > 0;) {
 		res = (f) (fd, iov, iovcnt);
 		switch (res) {
@@ -125,9 +134,6 @@
 			if (errno == EINTR)
 				continue;
 			if (errno == EAGAIN || errno == EWOULDBLOCK) {
-#ifndef BROKEN_READV_COMPARISON
-				(void)poll(&pfd, 1, -1);
-#endif
 				continue;
 			}
 			return 0;
diff -ruN openssh-7.3p1/atomicio.h openssh-7.3p1.aros/atomicio.h
--- openssh-7.3p1/atomicio.h	2016-07-28 00:54:27.000000000 +0200
+++ openssh-7.3p1.aros/atomicio.h	2016-08-01 04:01:55.000000000 +0200
@@ -35,7 +35,8 @@
 size_t
 atomicio6(ssize_t (*f) (int, void *, size_t), int fd, void *_s, size_t n,
     int (*cb)(void *, size_t), void *);
-size_t	atomicio(ssize_t (*)(int, void *, size_t), int, void *, size_t);
+size_t	atomicio_loc(ssize_t (*)(int, void *, size_t), int, void *, size_t);
+size_t	atomicio_net(ssize_t (*)(int, void *, size_t), int, void *, size_t);
 
 #define vwrite (ssize_t (*)(int, void *, size_t))write
 
diff -ruN openssh-7.3p1/auth2.c openssh-7.3p1.aros/auth2.c
--- openssh-7.3p1/auth2.c	2016-07-28 00:54:27.000000000 +0200
+++ openssh-7.3p1.aros/auth2.c	2016-08-11 19:05:30.102673483 +0200
@@ -121,7 +121,7 @@
 
 	len = (size_t)st.st_size;		/* truncate */
 	banner = xmalloc(len + 1);
-	n = atomicio(read, fd, banner, len);
+	n = atomicio_loc(read, fd, banner, len);
 	close(fd);
 
 	if (n != len) {
diff -ruN openssh-7.3p1/auth2-pubkey.c openssh-7.3p1.aros/auth2-pubkey.c
--- openssh-7.3p1/auth2-pubkey.c	2016-07-28 00:54:27.000000000 +0200
+++ openssh-7.3p1.aros/auth2-pubkey.c	2016-08-01 04:01:55.000000000 +0200
@@ -460,8 +460,9 @@
 		if ((cp = getenv("LANG")) != NULL)
 			child_set_env(&child_env, &envsize, "LANG", cp);
 
-		for (i = 0; i < NSIG; i++)
-			signal(i, SIG_DFL);
+//		for (i = 0; i < NSIG; i++)
+//			signal(i, SIG_DFL);
+		asm("int3");
 
 		if ((devnull = open(_PATH_DEVNULL, O_RDWR)) == -1) {
 			error("%s: open %s: %s", tag, _PATH_DEVNULL,
diff -ruN openssh-7.3p1/authfd.c openssh-7.3p1.aros/authfd.c
--- openssh-7.3p1/authfd.c	2016-07-28 00:54:27.000000000 +0200
+++ openssh-7.3p1.aros/authfd.c	2016-08-11 19:01:56.129387042 +0200
@@ -133,15 +133,15 @@
 	put_u32(buf, len);
 
 	/* Send the length and then the packet to the agent. */
-	if (atomicio(vwrite, sock, buf, 4) != 4 ||
-	    atomicio(vwrite, sock, (u_char *)sshbuf_ptr(request),
+	if (atomicio_net(vwrite, sock, buf, 4) != 4 ||
+	    atomicio_net(vwrite, sock, (u_char *)sshbuf_ptr(request),
 	    sshbuf_len(request)) != sshbuf_len(request))
 		return SSH_ERR_AGENT_COMMUNICATION;
 	/*
 	 * Wait for response from the agent.  First read the length of the
 	 * response packet.
 	 */
-	if (atomicio(read, sock, buf, 4) != 4)
+	if (atomicio_net(read, sock, buf, 4) != 4)
 	    return SSH_ERR_AGENT_COMMUNICATION;
 
 	/* Extract the length, and check it for sanity. */
@@ -155,7 +155,7 @@
 		l = len;
 		if (l > sizeof(buf))
 			l = sizeof(buf);
-		if (atomicio(read, sock, buf, l) != l)
+		if (atomicio_net(read, sock, buf, l) != l)
 			return SSH_ERR_AGENT_COMMUNICATION;
 		if ((r = sshbuf_put(reply, buf, l)) != 0)
 			return r;
diff -ruN openssh-7.3p1/authfile.c openssh-7.3p1.aros/authfile.c
--- openssh-7.3p1/authfile.c	2016-07-28 00:54:27.000000000 +0200
+++ openssh-7.3p1.aros/authfile.c	2016-08-11 19:02:42.213664109 +0200
@@ -60,7 +60,7 @@
 
 	if ((fd = open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0600)) < 0)
 		return SSH_ERR_SYSTEM_ERROR;
-	if (atomicio(vwrite, fd, (u_char *)sshbuf_ptr(keybuf),
+	if (atomicio_loc(vwrite, fd, (u_char *)sshbuf_ptr(keybuf),
 	    sshbuf_len(keybuf)) != sshbuf_len(keybuf)) {
 		oerrno = errno;
 		close(fd);
@@ -108,7 +108,7 @@
 	    st.st_size > MAX_KEY_FILE_SIZE)
 		return SSH_ERR_INVALID_FORMAT;
 	for (;;) {
-		if ((len = atomicio(read, fd, buf, sizeof(buf))) == 0) {
+		if ((len = atomicio_loc(read, fd, buf, sizeof(buf))) == 0) {
 			if (errno == EPIPE)
 				break;
 			r = SSH_ERR_SYSTEM_ERROR;
diff -ruN openssh-7.3p1/channels.c openssh-7.3p1.aros/channels.c
--- openssh-7.3p1/channels.c	2016-07-28 00:54:27.000000000 +0200
+++ openssh-7.3p1.aros/channels.c	2016-08-14 19:51:33.897886878 +0200
@@ -83,6 +83,10 @@
 #include "authfd.h"
 #include "pathnames.h"
 
+#ifdef __AROS__
+#include <proto/dos.h>
+#endif
+
 /* -- channel core */
 
 /*
@@ -359,6 +363,9 @@
 	c->mux_pause = 0;
 	c->delayed = 1;		/* prevent call to channel_post handler */
 	TAILQ_INIT(&c->status_confirms);
+#ifdef __AROS__
+	c->aros_console_mode = 0;
+#endif
 	debug("channel %d: new [%s]", found, remote_name);
 	return c;
 }
@@ -852,6 +859,10 @@
 	    limit > 0 &&
 	    buffer_len(&c->input) < limit &&
 	    buffer_check_alloc(&c->input, CHAN_RBUF))
+#ifdef __AROS__
+	    if (c->aros_console_mode == 1)
+	        if (WaitForChar(Input(), 0) != 0)
+#endif
 		FD_SET(c->rfd, readset);
 	if (c->ostate == CHAN_OUTPUT_OPEN ||
 	    c->ostate == CHAN_OUTPUT_WAIT_DRAIN) {
diff -ruN openssh-7.3p1/channels.h openssh-7.3p1.aros/channels.h
--- openssh-7.3p1/channels.h	2016-07-28 00:54:27.000000000 +0200
+++ openssh-7.3p1.aros/channels.h	2016-08-14 19:50:16.117524800 +0200
@@ -162,6 +162,9 @@
 	mux_callback_fn		*mux_rcb;
 	void			*mux_ctx;
 	int			mux_pause;
+#ifdef __AROS__
+	int aros_console_mode;
+#endif
 };
 
 #define CHAN_EXTENDED_IGNORE		0
diff -ruN openssh-7.3p1/clientloop.c openssh-7.3p1.aros/clientloop.c
--- openssh-7.3p1/clientloop.c	2016-07-28 00:54:27.000000000 +0200
+++ openssh-7.3p1.aros/clientloop.c	2016-08-14 20:46:12.681150037 +0200
@@ -217,6 +217,7 @@
 	set_nonblock(fileno(stdin));
 }
 
+#ifndef __AROS__
 /*
  * Signal handler for the window change signal (SIGWINCH).  This just sets a
  * flag indicating that the window has changed.
@@ -228,6 +229,7 @@
 	received_window_change_signal = 1;
 	signal(SIGWINCH, window_change_handler);
 }
+#endif
 
 /*
  * Signal handler for signals that cause the program to terminate.  These
@@ -690,7 +692,52 @@
 		tvp = &tv;
 	}
 
+#ifdef __AROS__
+    /* AROS logic is different than original:
+     * 1) The channel_pre_open FD_SETs the console fd only if there is
+     *    data on the Input(). This means the blocking read call in
+     *    channel_handle_rfd will only happen if there is something to read
+     * 2) The select call is issued only on network sockets. It timeouts out
+     *    after 80ms.
+     * 3) If there is any fd "set" other then network, select is not issued
+     *    as select understands only network fd, not file fd. In such case
+     *    all file fd are marked (even though this might not be real situation)
+     *
+     * This means the logic is based on pooling instead of event based like
+     * in initial code.
+     *
+     */
+    {
+        fd_set rtmp, wtmp;
+        rtmp = **readsetp;
+        wtmp = **writesetp;
+        FD_CLR(connection_in, &rtmp);
+        FD_CLR(connection_out, &wtmp);
+        if ((rtmp.fds_bits[0] != 0) || (wtmp.fds_bits[0] != 0))
+        {
+            ret = 1;
+            FD_CLR(connection_in, *readsetp);
+            FD_CLR(connection_out, *writesetp);
+        }
+        else
+        {
+            FD_ZERO(&rtmp); FD_ZERO(&wtmp);
+            if (FD_ISSET(connection_in, *readsetp)) FD_SET(connection_in, &rtmp);
+            if (FD_ISSET(connection_out, *writesetp)) FD_SET(connection_out, &wtmp);
+            **readsetp = rtmp;
+            **writesetp = wtmp;
+
+            tv.tv_sec = 0;
+            tv.tv_usec = 80000;
+            tvp = &tv;
+
+            ret = select((*maxfdp)+1, *readsetp, *writesetp, NULL, tvp);
+        }
+
+    }
+#else
 	ret = select((*maxfdp)+1, *readsetp, *writesetp, NULL, tvp);
+#endif
 	if (ret < 0) {
 		char buf[100];
 
@@ -724,10 +771,10 @@
 {
 	/* Flush stdout and stderr buffers. */
 	if (buffer_len(bout) > 0)
-		atomicio(vwrite, fileno(stdout), buffer_ptr(bout),
+		atomicio_loc(vwrite, fileno(stdout), buffer_ptr(bout),
 		    buffer_len(bout));
 	if (buffer_len(berr) > 0)
-		atomicio(vwrite, fileno(stderr), buffer_ptr(berr),
+		atomicio_loc(vwrite, fileno(stderr), buffer_ptr(berr),
 		    buffer_len(berr));
 
 	leave_raw_mode(options.request_tty == REQUEST_TTY_FORCE);
@@ -766,7 +813,11 @@
 	 */
 	if (FD_ISSET(connection_in, readset)) {
 		/* Read as much as possible. */
+#ifdef __AROS__
+		len = recv(connection_in, buf, sizeof(buf), 0);
+#else
 		len = read(connection_in, buf, sizeof(buf));
+#endif
 		if (len == 0) {
 			/*
 			 * Received EOF.  The remote host has closed the
@@ -1589,7 +1640,9 @@
 		signal(SIGQUIT, signal_handler);
 	if (signal(SIGTERM, SIG_IGN) != SIG_IGN)
 		signal(SIGTERM, signal_handler);
+#ifndef __AROS__
 	signal(SIGWINCH, window_change_handler);
+#endif
 
 	if (have_pty)
 		enter_raw_mode(options.request_tty == REQUEST_TTY_FORCE);
@@ -1710,7 +1763,9 @@
 	/* Terminate the session. */
 
 	/* Stop watching for window change. */
+#ifndef __AROS__
 	signal(SIGWINCH, SIG_DFL);
+#endif
 
 	if (compat20) {
 		packet_start(SSH2_MSG_DISCONNECT);
@@ -1759,7 +1814,7 @@
 
 	/* Output any buffered data for stdout. */
 	if (buffer_len(&stdout_buffer) > 0) {
-		len = atomicio(vwrite, fileno(stdout),
+		len = atomicio_loc(vwrite, fileno(stdout),
 		    buffer_ptr(&stdout_buffer), buffer_len(&stdout_buffer));
 		if (len < 0 || (u_int)len != buffer_len(&stdout_buffer))
 			error("Write failed flushing stdout buffer.");
@@ -1769,7 +1824,7 @@
 
 	/* Output any buffered data for stderr. */
 	if (buffer_len(&stderr_buffer) > 0) {
-		len = atomicio(vwrite, fileno(stderr),
+		len = atomicio_loc(vwrite, fileno(stderr),
 		    buffer_ptr(&stderr_buffer), buffer_len(&stderr_buffer));
 		if (len < 0 || (u_int)len != buffer_len(&stderr_buffer))
 			error("Write failed flushing stderr buffer.");
diff -ruN openssh-7.3p1/defines.h openssh-7.3p1.aros/defines.h
--- openssh-7.3p1/defines.h	2016-07-28 00:54:27.000000000 +0200
+++ openssh-7.3p1.aros/defines.h	2016-08-01 04:01:55.000000000 +0200
@@ -342,7 +342,7 @@
 #endif /* HAVE_CLOCK_T */
 
 #ifndef HAVE_SA_FAMILY_T
-typedef int sa_family_t;
+typedef unsigned char sa_family_t;
 # define HAVE_SA_FAMILY_T
 #endif /* HAVE_SA_FAMILY_T */
 
diff -ruN openssh-7.3p1/hostfile.c openssh-7.3p1.aros/hostfile.c
--- openssh-7.3p1/hostfile.c	2016-07-28 00:54:27.000000000 +0200
+++ openssh-7.3p1.aros/hostfile.c	2016-08-01 04:01:55.000000000 +0200
@@ -44,7 +44,6 @@
 #include <netinet/in.h>
 
 #include <errno.h>
-#include <resolv.h>
 #include <stdarg.h>
 #include <stdio.h>
 #include <stdlib.h>
diff -ruN openssh-7.3p1/includes.h openssh-7.3p1.aros/includes.h
--- openssh-7.3p1/includes.h	2016-07-28 00:54:27.000000000 +0200
+++ openssh-7.3p1.aros/includes.h	2016-08-01 04:01:55.000000000 +0200
@@ -16,6 +16,8 @@
 #ifndef INCLUDES_H
 #define INCLUDES_H
 
+#define _STDC_NOINLINE_MBTOWC
+
 #include "config.h"
 
 #ifndef _GNU_SOURCE
@@ -170,6 +172,7 @@
 #include "platform.h"
 #include "openbsd-compat/openbsd-compat.h"
 #include "openbsd-compat/bsd-nextstep.h"
+#include "openbsd-compat/port-aros.h"
 
 #include "entropy.h"
 
diff -ruN openssh-7.3p1/loginrec.c openssh-7.3p1.aros/loginrec.c
--- openssh-7.3p1/loginrec.c	2016-07-28 00:54:27.000000000 +0200
+++ openssh-7.3p1.aros/loginrec.c	2016-08-01 04:01:55.000000000 +0200
@@ -1032,7 +1032,7 @@
 		return (0);
 	}
 # else
-	if (!utmpx_write_direct(li, &ut)) {
+	if (!utmpx_write_direct(li, &utx)) {
 		logit("%s: utmp_write_direct() failed", __func__);
 		return (0);
 	}
diff -ruN openssh-7.3p1/Makefile.in openssh-7.3p1.aros/Makefile.in
--- openssh-7.3p1/Makefile.in	2016-07-28 00:54:27.000000000 +0200
+++ openssh-7.3p1.aros/Makefile.in	2016-08-01 04:01:55.000000000 +0200
@@ -28,7 +28,7 @@
 SSH_PKCS11_HELPER=$(libexecdir)/ssh-pkcs11-helper
 PRIVSEP_PATH=@PRIVSEP_PATH@
 SSH_PRIVSEP_USER=@SSH_PRIVSEP_USER@
-STRIP_OPT=@STRIP_OPT@
+STRIP_OPT=
 TEST_SHELL=@TEST_SHELL@
 
 PATHS= -DSSHDIR=\"$(sysconfdir)\" \
@@ -161,37 +161,37 @@
 	$(RANLIB) $@
 
 ssh$(EXEEXT): $(LIBCOMPAT) libssh.a $(SSHOBJS)
-	$(LD) -o $@ $(SSHOBJS) $(LDFLAGS) -lssh -lopenbsd-compat $(SSHLIBS) $(LIBS) $(GSSLIBS)
+	$(LD) -o $@ $(SSHOBJS) $(LDFLAGS) -lssh -lopenbsd-compat -lnet $(SSHLIBS) $(LIBS) $(GSSLIBS)
 
 sshd$(EXEEXT): libssh.a	$(LIBCOMPAT) $(SSHDOBJS)
-	$(LD) -o $@ $(SSHDOBJS) $(LDFLAGS) -lssh -lopenbsd-compat $(SSHDLIBS) $(LIBS) $(GSSLIBS) $(K5LIBS)
+	$(LD) -o $@ $(SSHDOBJS) $(LDFLAGS) -lssh -lopenbsd-compat -lnet $(SSHDLIBS) $(LIBS) $(GSSLIBS) $(K5LIBS)
 
 scp$(EXEEXT): $(LIBCOMPAT) libssh.a scp.o progressmeter.o
-	$(LD) -o $@ scp.o progressmeter.o bufaux.o $(LDFLAGS) -lssh -lopenbsd-compat $(LIBS)
+	$(LD) -o $@ scp.o progressmeter.o bufaux.o $(LDFLAGS) -lssh -lopenbsd-compat -lnet $(LIBS)
 
 ssh-add$(EXEEXT): $(LIBCOMPAT) libssh.a ssh-add.o
-	$(LD) -o $@ ssh-add.o $(LDFLAGS) -lssh -lopenbsd-compat $(LIBS)
+	$(LD) -o $@ ssh-add.o $(LDFLAGS) -lssh -lopenbsd-compat -lnet $(LIBS)
 
 ssh-agent$(EXEEXT): $(LIBCOMPAT) libssh.a ssh-agent.o ssh-pkcs11-client.o
-	$(LD) -o $@ ssh-agent.o ssh-pkcs11-client.o $(LDFLAGS) -lssh -lopenbsd-compat $(LIBS)
+	$(LD) -o $@ ssh-agent.o ssh-pkcs11-client.o $(LDFLAGS) -lssh -lopenbsd-compat -lnet $(LIBS)
 
 ssh-keygen$(EXEEXT): $(LIBCOMPAT) libssh.a ssh-keygen.o
-	$(LD) -o $@ ssh-keygen.o $(LDFLAGS) -lssh -lopenbsd-compat $(LIBS)
+	$(LD) -o $@ ssh-keygen.o $(LDFLAGS) -lssh -lopenbsd-compat -lnet $(LIBS)
 
 ssh-keysign$(EXEEXT): $(LIBCOMPAT) libssh.a ssh-keysign.o readconf.o
-	$(LD) -o $@ ssh-keysign.o readconf.o $(LDFLAGS) -lssh -lopenbsd-compat $(LIBS)
+	$(LD) -o $@ ssh-keysign.o readconf.o $(LDFLAGS) -lssh -lopenbsd-compat -lnet $(LIBS)
 
 ssh-pkcs11-helper$(EXEEXT): $(LIBCOMPAT) libssh.a ssh-pkcs11-helper.o ssh-pkcs11.o
-	$(LD) -o $@ ssh-pkcs11-helper.o ssh-pkcs11.o $(LDFLAGS) -lssh -lopenbsd-compat -lssh -lopenbsd-compat $(LIBS)
+	$(LD) -o $@ ssh-pkcs11-helper.o ssh-pkcs11.o $(LDFLAGS) -lssh -lopenbsd-compat -lssh -lopenbsd-compat -lnet $(LIBS)
 
 ssh-keyscan$(EXEEXT): $(LIBCOMPAT) libssh.a ssh-keyscan.o
-	$(LD) -o $@ ssh-keyscan.o $(LDFLAGS) -lssh -lopenbsd-compat -lssh $(LIBS)
+	$(LD) -o $@ ssh-keyscan.o $(LDFLAGS) -lssh -lopenbsd-compat -lssh -lnet $(LIBS)
 
 sftp-server$(EXEEXT): $(LIBCOMPAT) libssh.a sftp.o sftp-common.o sftp-server.o sftp-server-main.o
-	$(LD) -o $@ sftp-server.o sftp-common.o sftp-server-main.o $(LDFLAGS) -lssh -lopenbsd-compat $(LIBS)
+	$(LD) -o $@ sftp-server.o sftp-common.o sftp-server-main.o $(LDFLAGS) -lssh -lopenbsd-compat -lnet $(LIBS)
 
 sftp$(EXEEXT): $(LIBCOMPAT) libssh.a sftp.o sftp-client.o sftp-common.o sftp-glob.o progressmeter.o
-	$(LD) -o $@ progressmeter.o sftp.o sftp-client.o sftp-common.o sftp-glob.o $(LDFLAGS) -lssh -lopenbsd-compat $(LIBS) $(LIBEDIT)
+	$(LD) -o $@ progressmeter.o sftp.o sftp-client.o sftp-common.o sftp-glob.o $(LDFLAGS) -lssh -lopenbsd-compat -lnet $(LIBS) $(LIBEDIT)
 
 # test driver for the loginrec code - not built by default
 logintest: logintest.o $(LIBCOMPAT) libssh.a loginrec.o
@@ -289,7 +289,7 @@
 	$(AUTORECONF)
 	-rm -rf autom4te.cache
 
-install: $(CONFIGFILES) $(MANPAGES) $(TARGETS) install-files install-sysconf host-key check-config
+install: $(CONFIGFILES) $(MANPAGES) $(TARGETS) install-files install-sysconf
 install-nokeys: $(CONFIGFILES) $(MANPAGES) $(TARGETS) install-files install-sysconf
 install-nosysconf: $(CONFIGFILES) $(MANPAGES) $(TARGETS) install-files
 
@@ -304,7 +304,6 @@
 	$(srcdir)/mkinstalldirs $(DESTDIR)$(mandir)/$(mansubdir)5
 	$(srcdir)/mkinstalldirs $(DESTDIR)$(mandir)/$(mansubdir)8
 	$(srcdir)/mkinstalldirs $(DESTDIR)$(libexecdir)
-	(umask 022 ; $(srcdir)/mkinstalldirs $(DESTDIR)$(PRIVSEP_PATH))
 	$(INSTALL) -m 0755 $(STRIP_OPT) ssh$(EXEEXT) $(DESTDIR)$(bindir)/ssh$(EXEEXT)
 	$(INSTALL) -m 0755 $(STRIP_OPT) scp$(EXEEXT) $(DESTDIR)$(bindir)/scp$(EXEEXT)
 	$(INSTALL) -m 0755 $(STRIP_OPT) ssh-add$(EXEEXT) $(DESTDIR)$(bindir)/ssh-add$(EXEEXT)
diff -ruN openssh-7.3p1/monitor.c openssh-7.3p1.aros/monitor.c
--- openssh-7.3p1/monitor.c	2016-07-28 00:54:27.000000000 +0200
+++ openssh-7.3p1.aros/monitor.c	2016-08-11 19:07:18.431324771 +0200
@@ -511,7 +511,7 @@
 
 	/* Read length */
 	buffer_append_space(&logmsg, 4);
-	if (atomicio(read, pmonitor->m_log_recvfd,
+	if (atomicio_loc(read, pmonitor->m_log_recvfd,
 	    buffer_ptr(&logmsg), buffer_len(&logmsg)) != buffer_len(&logmsg)) {
 		if (errno == EPIPE) {
 			buffer_free(&logmsg);
@@ -529,7 +529,7 @@
 	/* Read severity, message */
 	buffer_clear(&logmsg);
 	buffer_append_space(&logmsg, len);
-	if (atomicio(read, pmonitor->m_log_recvfd,
+	if (atomicio_loc(read, pmonitor->m_log_recvfd,
 	    buffer_ptr(&logmsg), buffer_len(&logmsg)) != buffer_len(&logmsg))
 		fatal("%s: log fd read: %s", __func__, strerror(errno));
 
diff -ruN openssh-7.3p1/monitor_wrap.c openssh-7.3p1.aros/monitor_wrap.c
--- openssh-7.3p1/monitor_wrap.c	2016-07-28 00:54:27.000000000 +0200
+++ openssh-7.3p1.aros/monitor_wrap.c	2016-08-11 19:06:45.159124734 +0200
@@ -112,7 +112,7 @@
 	buffer_put_int(&log_msg, level);
 	buffer_put_cstring(&log_msg, msg);
 	put_u32(buffer_ptr(&log_msg), buffer_len(&log_msg) - 4);
-	if (atomicio(vwrite, mon->m_log_sendfd, buffer_ptr(&log_msg),
+	if (atomicio_loc(vwrite, mon->m_log_sendfd, buffer_ptr(&log_msg),
 	    buffer_len(&log_msg)) != buffer_len(&log_msg))
 		fatal("%s: write: %s", __func__, strerror(errno));
 	buffer_free(&log_msg);
@@ -138,9 +138,9 @@
 
 	put_u32(buf, mlen + 1);
 	buf[4] = (u_char) type;		/* 1st byte of payload is mesg-type */
-	if (atomicio(vwrite, sock, buf, sizeof(buf)) != sizeof(buf))
+	if (atomicio_net(vwrite, sock, buf, sizeof(buf)) != sizeof(buf))
 		fatal("%s: write: %s", __func__, strerror(errno));
-	if (atomicio(vwrite, sock, buffer_ptr(m), mlen) != mlen)
+	if (atomicio_net(vwrite, sock, buffer_ptr(m), mlen) != mlen)
 		fatal("%s: write: %s", __func__, strerror(errno));
 }
 
@@ -152,7 +152,7 @@
 
 	debug3("%s entering", __func__);
 
-	if (atomicio(read, sock, buf, sizeof(buf)) != sizeof(buf)) {
+	if (atomicio_net(read, sock, buf, sizeof(buf)) != sizeof(buf)) {
 		if (errno == EPIPE)
 			cleanup_exit(255);
 		fatal("%s: read: %s", __func__, strerror(errno));
@@ -162,7 +162,7 @@
 		fatal("%s: read: bad msg_len %d", __func__, msg_len);
 	buffer_clear(m);
 	buffer_append_space(m, msg_len);
-	if (atomicio(read, sock, buffer_ptr(m), msg_len) != msg_len)
+	if (atomicio_net(read, sock, buffer_ptr(m), msg_len) != msg_len)
 		fatal("%s: read: %s", __func__, strerror(errno));
 }
 
diff -ruN openssh-7.3p1/msg.c openssh-7.3p1.aros/msg.c
--- openssh-7.3p1/msg.c	2016-07-28 00:54:27.000000000 +0200
+++ openssh-7.3p1.aros/msg.c	2016-08-11 19:03:48.718063944 +0200
@@ -51,11 +51,11 @@
 
 	put_u32(buf, mlen + 1);
 	buf[4] = type;		/* 1st byte of payload is mesg-type */
-	if (atomicio(vwrite, fd, buf, sizeof(buf)) != sizeof(buf)) {
+	if (atomicio_net(vwrite, fd, buf, sizeof(buf)) != sizeof(buf)) {
 		error("ssh_msg_send: write");
 		return (-1);
 	}
-	if (atomicio(vwrite, fd, (u_char *)sshbuf_ptr(m), mlen) != mlen) {
+	if (atomicio_net(vwrite, fd, (u_char *)sshbuf_ptr(m), mlen) != mlen) {
 		error("ssh_msg_send: write");
 		return (-1);
 	}
@@ -71,7 +71,7 @@
 
 	debug3("ssh_msg_recv entering");
 
-	if (atomicio(read, fd, buf, sizeof(buf)) != sizeof(buf)) {
+	if (atomicio_net(read, fd, buf, sizeof(buf)) != sizeof(buf)) {
 		if (errno != EPIPE)
 			error("ssh_msg_recv: read: header");
 		return (-1);
@@ -86,7 +86,7 @@
 		error("%s: buffer error: %s", __func__, ssh_err(r));
 		return -1;
 	}
-	if (atomicio(read, fd, p, msg_len) != msg_len) {
+	if (atomicio_net(read, fd, p, msg_len) != msg_len) {
 		error("ssh_msg_recv: read: %s", strerror(errno));
 		return (-1);
 	}
diff -ruN openssh-7.3p1/mux.c openssh-7.3p1.aros/mux.c
--- openssh-7.3p1/mux.c	2016-07-28 00:54:27.000000000 +0200
+++ openssh-7.3p1.aros/mux.c	2016-08-01 04:01:55.000000000 +0200
@@ -1896,7 +1896,8 @@
 	signal(SIGHUP, control_client_sighandler);
 	signal(SIGINT, control_client_sighandler);
 	signal(SIGTERM, control_client_sighandler);
-	signal(SIGWINCH, control_client_sigrelay);
+//	signal(SIGWINCH, control_client_sigrelay);
+	asm("int3");
 
 	rawmode = tty_flag;
 	if (tty_flag)
@@ -2044,7 +2045,8 @@
 	signal(SIGHUP, control_client_sighandler);
 	signal(SIGINT, control_client_sighandler);
 	signal(SIGTERM, control_client_sighandler);
-	signal(SIGWINCH, control_client_sigrelay);
+//	signal(SIGWINCH, control_client_sigrelay);
+	asm("int3");
 
 	/*
 	 * Stick around until the controlee closes the client_fd.
diff -ruN openssh-7.3p1/openbsd-compat/bsd-closefrom.c openssh-7.3p1.aros/openbsd-compat/bsd-closefrom.c
--- openssh-7.3p1/openbsd-compat/bsd-closefrom.c	2016-07-28 00:54:27.000000000 +0200
+++ openssh-7.3p1.aros/openbsd-compat/bsd-closefrom.c	2016-08-01 04:01:55.000000000 +0200
@@ -69,7 +69,7 @@
 closefrom(int lowfd)
 {
     long fd, maxfd;
-#if defined(HAVE_DIRFD) && defined(HAVE_PROC_PID)
+#if 0 /* defined(HAVE_DIRFD) && defined(HAVE_PROC_PID) */
     char fdpath[PATH_MAX], *endp;
     struct dirent *dent;
     DIR *dirp;
diff -ruN openssh-7.3p1/openbsd-compat/bsd-err.c openssh-7.3p1.aros/openbsd-compat/bsd-err.c
--- openssh-7.3p1/openbsd-compat/bsd-err.c	2016-07-28 00:54:27.000000000 +0200
+++ openssh-7.3p1.aros/openbsd-compat/bsd-err.c	2016-08-01 04:01:55.000000000 +0200
@@ -26,6 +26,7 @@
  */
 
 #include "includes.h"
+#include <string.h>
 
 #ifndef HAVE_ERR
 void
diff -ruN openssh-7.3p1/openbsd-compat/bsd-misc.c openssh-7.3p1.aros/openbsd-compat/bsd-misc.c
--- openssh-7.3p1/openbsd-compat/bsd-misc.c	2016-07-28 00:54:27.000000000 +0200
+++ openssh-7.3p1.aros/openbsd-compat/bsd-misc.c	2016-08-01 04:01:55.000000000 +0200
@@ -183,10 +183,11 @@
 {
 	int ctty_pgrp;
 
-	if (ioctl(fd, TIOCGPGRP, &ctty_pgrp) == -1)
-		return(-1);
-	else
-		return(ctty_pgrp);
+//	if (ioctl(fd, TIOCGPGRP, &ctty_pgrp) == -1)
+//		return(-1);
+//	else
+//		return(ctty_pgrp);
+	asm("int3");
 }
 #endif /* HAVE_TCGETPGRP */
 
diff -ruN openssh-7.3p1/openbsd-compat/getrrsetbyname.c openssh-7.3p1.aros/openbsd-compat/getrrsetbyname.c
--- openssh-7.3p1/openbsd-compat/getrrsetbyname.c	2016-07-28 00:54:27.000000000 +0200
+++ openssh-7.3p1.aros/openbsd-compat/getrrsetbyname.c	2016-08-01 04:01:55.000000000 +0200
@@ -45,7 +45,7 @@
 
 /* OPENBSD ORIGINAL: lib/libc/net/getrrsetbyname.c */
 
-#include "includes.h"
+//#include "includes.h"
 
 #if !defined (HAVE_GETRRSETBYNAME) && !defined (HAVE_LDNS)
 
@@ -68,7 +68,7 @@
 #define _THREAD_PRIVATE(a,b,c) (c)
 
 #ifndef HAVE__RES_EXTERN
-struct __res_state _res;
+//struct __res_state _res;
 #endif
 
 /* Necessary functions and macros */
@@ -114,7 +114,7 @@
  */
 
 #ifndef HAVE__GETSHORT
-static u_int16_t
+u_short
 _getshort(msgp)
 	register const u_char *msgp;
 {
@@ -128,7 +128,7 @@
 #endif
 
 #ifndef HAVE__GETLONG
-static u_int32_t
+u_long
 _getlong(msgp)
 	register const u_char *msgp;
 {
@@ -187,162 +187,164 @@
     unsigned int rdtype, unsigned int flags,
     struct rrsetinfo **res)
 {
-	struct __res_state *_resp = _THREAD_PRIVATE(_res, _res, &_res);
-	int result;
-	struct rrsetinfo *rrset = NULL;
-	struct dns_response *response = NULL;
-	struct dns_rr *rr;
-	struct rdatainfo *rdata;
-	int length;
-	unsigned int index_ans, index_sig;
-	u_char answer[ANSWER_BUFFER_SIZE];
-
-	/* check for invalid class and type */
-	if (rdclass > 0xffff || rdtype > 0xffff) {
-		result = ERRSET_INVAL;
-		goto fail;
-	}
-
-	/* don't allow queries of class or type ANY */
-	if (rdclass == 0xff || rdtype == 0xff) {
-		result = ERRSET_INVAL;
-		goto fail;
-	}
-
-	/* don't allow flags yet, unimplemented */
-	if (flags) {
-		result = ERRSET_INVAL;
-		goto fail;
-	}
-
-	/* initialize resolver */
-	if ((_resp->options & RES_INIT) == 0 && res_init() == -1) {
-		result = ERRSET_FAIL;
-		goto fail;
-	}
-
-#ifdef DEBUG
-	_resp->options |= RES_DEBUG;
-#endif /* DEBUG */
-
-#ifdef RES_USE_DNSSEC
-	/* turn on DNSSEC if EDNS0 is configured */
-	if (_resp->options & RES_USE_EDNS0)
-		_resp->options |= RES_USE_DNSSEC;
-#endif /* RES_USE_DNSEC */
-
-	/* make query */
-	length = res_query(hostname, (signed int) rdclass, (signed int) rdtype,
-	    answer, sizeof(answer));
-	if (length < 0) {
-		switch(h_errno) {
-		case HOST_NOT_FOUND:
-			result = ERRSET_NONAME;
-			goto fail;
-		case NO_DATA:
-			result = ERRSET_NODATA;
-			goto fail;
-		default:
-			result = ERRSET_FAIL;
-			goto fail;
-		}
-	}
-
-	/* parse result */
-	response = parse_dns_response(answer, length);
-	if (response == NULL) {
-		result = ERRSET_FAIL;
-		goto fail;
-	}
-
-	if (response->header.qdcount != 1) {
-		result = ERRSET_FAIL;
-		goto fail;
-	}
-
-	/* initialize rrset */
-	rrset = calloc(1, sizeof(struct rrsetinfo));
-	if (rrset == NULL) {
-		result = ERRSET_NOMEMORY;
-		goto fail;
-	}
-	rrset->rri_rdclass = response->query->class;
-	rrset->rri_rdtype = response->query->type;
-	rrset->rri_ttl = response->answer->ttl;
-	rrset->rri_nrdatas = response->header.ancount;
-
-#ifdef HAVE_HEADER_AD
-	/* check for authenticated data */
-	if (response->header.ad == 1)
-		rrset->rri_flags |= RRSET_VALIDATED;
-#endif
-
-	/* copy name from answer section */
-	rrset->rri_name = strdup(response->answer->name);
-	if (rrset->rri_name == NULL) {
-		result = ERRSET_NOMEMORY;
-		goto fail;
-	}
-
-	/* count answers */
-	rrset->rri_nrdatas = count_dns_rr(response->answer, rrset->rri_rdclass,
-	    rrset->rri_rdtype);
-	rrset->rri_nsigs = count_dns_rr(response->answer, rrset->rri_rdclass,
-	    T_RRSIG);
-
-	/* allocate memory for answers */
-	rrset->rri_rdatas = calloc(rrset->rri_nrdatas,
-	    sizeof(struct rdatainfo));
-	if (rrset->rri_rdatas == NULL) {
-		result = ERRSET_NOMEMORY;
-		goto fail;
-	}
-
-	/* allocate memory for signatures */
-	if (rrset->rri_nsigs > 0) {
-		rrset->rri_sigs = calloc(rrset->rri_nsigs, sizeof(struct rdatainfo));
-		if (rrset->rri_sigs == NULL) {
-			result = ERRSET_NOMEMORY;
-			goto fail;
-		}
-	}
-
-	/* copy answers & signatures */
-	for (rr = response->answer, index_ans = 0, index_sig = 0;
-	    rr; rr = rr->next) {
-
-		rdata = NULL;
-
-		if (rr->class == rrset->rri_rdclass &&
-		    rr->type  == rrset->rri_rdtype)
-			rdata = &rrset->rri_rdatas[index_ans++];
-
-		if (rr->class == rrset->rri_rdclass &&
-		    rr->type  == T_RRSIG)
-			rdata = &rrset->rri_sigs[index_sig++];
-
-		if (rdata) {
-			rdata->rdi_length = rr->size;
-			rdata->rdi_data   = malloc(rr->size);
-
-			if (rdata->rdi_data == NULL) {
-				result = ERRSET_NOMEMORY;
-				goto fail;
-			}
-			memcpy(rdata->rdi_data, rr->rdata, rr->size);
-		}
-	}
-	free_dns_response(response);
-
-	*res = rrset;
-	return (ERRSET_SUCCESS);
-
-fail:
-	if (rrset != NULL)
-		freerrset(rrset);
-	if (response != NULL)
-		free_dns_response(response);
-	return (result);
+//	struct __res_state *_resp = _THREAD_PRIVATE(_res, _res, &_res);
+//	int result;
+//	struct rrsetinfo *rrset = NULL;
+//	struct dns_response *response = NULL;
+//	struct dns_rr *rr;
+//	struct rdatainfo *rdata;
+//	int length;
+//	unsigned int index_ans, index_sig;
+//	u_char answer[ANSWER_BUFFER_SIZE];
+//
+//	/* check for invalid class and type */
+//	if (rdclass > 0xffff || rdtype > 0xffff) {
+//		result = ERRSET_INVAL;
+//		goto fail;
+//	}
+//
+//	/* don't allow queries of class or type ANY */
+//	if (rdclass == 0xff || rdtype == 0xff) {
+//		result = ERRSET_INVAL;
+//		goto fail;
+//	}
+//
+//	/* don't allow flags yet, unimplemented */
+//	if (flags) {
+//		result = ERRSET_INVAL;
+//		goto fail;
+//	}
+//
+//	/* initialize resolver */
+//	if ((_resp->options & RES_INIT) == 0 && res_init() == -1) {
+//		result = ERRSET_FAIL;
+//		goto fail;
+//	}
+//
+//#ifdef DEBUG
+//	_resp->options |= RES_DEBUG;
+//#endif /* DEBUG */
+//
+//#ifdef RES_USE_DNSSEC
+//	/* turn on DNSSEC if EDNS0 is configured */
+//	if (_resp->options & RES_USE_EDNS0)
+//		_resp->options |= RES_USE_DNSSEC;
+//#endif /* RES_USE_DNSEC */
+//
+//	/* make query */
+//	length = res_query(hostname, (signed int) rdclass, (signed int) rdtype,
+//	    answer, sizeof(answer));
+//	if (length < 0) {
+//		switch(h_errno) {
+//		case HOST_NOT_FOUND:
+//			result = ERRSET_NONAME;
+//			goto fail;
+//		case NO_DATA:
+//			result = ERRSET_NODATA;
+//			goto fail;
+//		default:
+//			result = ERRSET_FAIL;
+//			goto fail;
+//		}
+//	}
+//
+//	/* parse result */
+//	response = parse_dns_response(answer, length);
+//	if (response == NULL) {
+//		result = ERRSET_FAIL;
+//		goto fail;
+//	}
+//
+//	if (response->header.qdcount != 1) {
+//		result = ERRSET_FAIL;
+//		goto fail;
+//	}
+//
+//	/* initialize rrset */
+//	rrset = calloc(1, sizeof(struct rrsetinfo));
+//	if (rrset == NULL) {
+//		result = ERRSET_NOMEMORY;
+//		goto fail;
+//	}
+//	rrset->rri_rdclass = response->query->class;
+//	rrset->rri_rdtype = response->query->type;
+//	rrset->rri_ttl = response->answer->ttl;
+//	rrset->rri_nrdatas = response->header.ancount;
+//
+//#ifdef HAVE_HEADER_AD
+//	/* check for authenticated data */
+//	if (response->header.ad == 1)
+//		rrset->rri_flags |= RRSET_VALIDATED;
+//#endif
+//
+//	/* copy name from answer section */
+//	rrset->rri_name = strdup(response->answer->name);
+//	if (rrset->rri_name == NULL) {
+//		result = ERRSET_NOMEMORY;
+//		goto fail;
+//	}
+//
+//	/* count answers */
+//	rrset->rri_nrdatas = count_dns_rr(response->answer, rrset->rri_rdclass,
+//	    rrset->rri_rdtype);
+//	rrset->rri_nsigs = count_dns_rr(response->answer, rrset->rri_rdclass,
+//	    T_RRSIG);
+//
+//	/* allocate memory for answers */
+//	rrset->rri_rdatas = calloc(rrset->rri_nrdatas,
+//	    sizeof(struct rdatainfo));
+//	if (rrset->rri_rdatas == NULL) {
+//		result = ERRSET_NOMEMORY;
+//		goto fail;
+//	}
+//
+//	/* allocate memory for signatures */
+//	if (rrset->rri_nsigs > 0) {
+//		rrset->rri_sigs = calloc(rrset->rri_nsigs, sizeof(struct rdatainfo));
+//		if (rrset->rri_sigs == NULL) {
+//			result = ERRSET_NOMEMORY;
+//			goto fail;
+//		}
+//	}
+//
+//	/* copy answers & signatures */
+//	for (rr = response->answer, index_ans = 0, index_sig = 0;
+//	    rr; rr = rr->next) {
+//
+//		rdata = NULL;
+//
+//		if (rr->class == rrset->rri_rdclass &&
+//		    rr->type  == rrset->rri_rdtype)
+//			rdata = &rrset->rri_rdatas[index_ans++];
+//
+//		if (rr->class == rrset->rri_rdclass &&
+//		    rr->type  == T_RRSIG)
+//			rdata = &rrset->rri_sigs[index_sig++];
+//
+//		if (rdata) {
+//			rdata->rdi_length = rr->size;
+//			rdata->rdi_data   = malloc(rr->size);
+//
+//			if (rdata->rdi_data == NULL) {
+//				result = ERRSET_NOMEMORY;
+//				goto fail;
+//			}
+//			memcpy(rdata->rdi_data, rr->rdata, rr->size);
+//		}
+//	}
+//	free_dns_response(response);
+//
+//	*res = rrset;
+//	return (ERRSET_SUCCESS);
+//
+//fail:
+//	if (rrset != NULL)
+//		freerrset(rrset);
+//	if (response != NULL)
+//		free_dns_response(response);
+//	return (result);
+    asm("int3");
+    return -1;
 }
 
 void
diff -ruN openssh-7.3p1/openbsd-compat/getrrsetbyname.h openssh-7.3p1.aros/openbsd-compat/getrrsetbyname.h
--- openssh-7.3p1/openbsd-compat/getrrsetbyname.h	2016-07-28 00:54:27.000000000 +0200
+++ openssh-7.3p1.aros/openbsd-compat/getrrsetbyname.h	2016-08-01 04:01:55.000000000 +0200
@@ -56,7 +56,6 @@
 #include <netinet/in.h>
 #include <arpa/nameser.h>
 #include <netdb.h>
-#include <resolv.h>
 
 #ifndef HFIXEDSZ
 #define HFIXEDSZ 12
diff -ruN openssh-7.3p1/openbsd-compat/inet_ntoa.c openssh-7.3p1.aros/openbsd-compat/inet_ntoa.c
--- openssh-7.3p1/openbsd-compat/inet_ntoa.c	2016-07-28 00:54:27.000000000 +0200
+++ openssh-7.3p1.aros/openbsd-compat/inet_ntoa.c	2016-08-01 04:01:55.000000000 +0200
@@ -34,26 +34,26 @@
 
 #if defined(BROKEN_INET_NTOA) || !defined(HAVE_INET_NTOA)
 
-/*
- * Convert network-format internet address
- * to base 256 d.d.d.d representation.
- */
-#include <sys/types.h>
-#include <netinet/in.h>
-#include <arpa/inet.h>
-#include <stdio.h>
-
-char *
-inet_ntoa(struct in_addr in)
-{
-	static char b[18];
-	char *p;
-
-	p = (char *)&in;
-#define	UC(b)	(((int)b)&0xff)
-	(void)snprintf(b, sizeof(b),
-	    "%u.%u.%u.%u", UC(p[0]), UC(p[1]), UC(p[2]), UC(p[3]));
-	return (b);
-}
+///*
+// * Convert network-format internet address
+// * to base 256 d.d.d.d representation.
+// */
+//#include <sys/types.h>
+//#include <netinet/in.h>
+//#include <arpa/inet.h>
+//#include <stdio.h>
+//
+//char *
+//inet_ntoa(struct in_addr in)
+//{
+//	static char b[18];
+//	char *p;
+//
+//	p = (char *)&in;
+//#define	UC(b)	(((int)b)&0xff)
+//	(void)snprintf(b, sizeof(b),
+//	    "%u.%u.%u.%u", UC(p[0]), UC(p[1]), UC(p[2]), UC(p[3]));
+//	return (b);
+//}
 
 #endif /* defined(BROKEN_INET_NTOA) || !defined(HAVE_INET_NTOA) */
diff -ruN openssh-7.3p1/openbsd-compat/Makefile.in openssh-7.3p1.aros/openbsd-compat/Makefile.in
--- openssh-7.3p1/openbsd-compat/Makefile.in	2016-07-28 00:54:27.000000000 +0200
+++ openssh-7.3p1.aros/openbsd-compat/Makefile.in	2016-08-01 04:01:55.000000000 +0200
@@ -20,7 +20,7 @@
 
 COMPAT=arc4random.o bsd-asprintf.o bsd-closefrom.o bsd-cray.o bsd-cygwin_util.o bsd-getpeereid.o getrrsetbyname-ldns.o bsd-err.o bsd-misc.o bsd-nextstep.o bsd-openpty.o bsd-poll.o bsd-setres_id.o bsd-snprintf.o bsd-statvfs.o bsd-waitpid.o fake-rfc2553.o openssl-compat.o xmmap.o xcrypt.o kludge-fd_set.o
 
-PORTS=port-aix.o port-irix.o port-linux.o port-solaris.o port-tun.o port-uw.o
+PORTS=port-aix.o port-irix.o port-linux.o port-solaris.o port-tun.o port-uw.o port-aros.o
 
 .c.o:
 	$(CC) $(CFLAGS) $(CPPFLAGS) -c $<
diff -ruN openssh-7.3p1/openbsd-compat/openbsd-compat.h openssh-7.3p1.aros/openbsd-compat/openbsd-compat.h
--- openssh-7.3p1/openbsd-compat/openbsd-compat.h	2016-07-28 00:54:27.000000000 +0200
+++ openssh-7.3p1.aros/openbsd-compat/openbsd-compat.h	2016-08-01 04:01:55.000000000 +0200
@@ -133,7 +133,7 @@
 #endif
 
 #if defined(BROKEN_INET_NTOA) || !defined(HAVE_INET_NTOA)
-char *inet_ntoa(struct in_addr in);
+//char *inet_ntoa(struct in_addr in);
 #endif
 
 #ifndef HAVE_INET_NTOP
diff -ruN openssh-7.3p1/openbsd-compat/port-aros.c openssh-7.3p1.aros/openbsd-compat/port-aros.c
--- openssh-7.3p1/openbsd-compat/port-aros.c	1970-01-01 01:00:00.000000000 +0100
+++ openssh-7.3p1.aros/openbsd-compat/port-aros.c	2016-08-01 04:01:55.000000000 +0200
@@ -0,0 +1,98 @@
+/*
+ * Copyright (c) 2000 Denis Parker.  All rights reserved.
+ * Copyright (c) 2000 Michael Stone.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "includes.h"
+
+#if defined(__AROS__)
+
+/* No-op */
+int setegid(gid_t gid)
+{
+    asm("int3");
+    return 0;
+}
+
+/* No-op */
+int setgroups(size_t size, const gid_t *groups)
+{
+    asm("int3");
+    return 0;
+}
+
+/* No-op */
+int setpgrp(pid_t pid, pid_t pgid)
+{
+    asm("int3");
+    return 1;
+}
+
+/* No-op */
+int initgroups(const char *user, gid_t group)
+{
+    asm("int3");
+    return 0;
+}
+
+/* Not implemented */
+int socketpair(int domain, int type, int protocol,
+       int socket_vector[2])
+{
+    asm("int3");
+    /* TODO: set errno */
+    return -1;
+}
+
+/* Not implemented */
+int dn_expand(unsigned char *msg, unsigned char *eomorig,unsigned char
+*comp_dn, char *exp_dn,int length)
+{
+    asm("int3");
+    return -1;
+}
+
+/* Not implemented */
+pid_t fork(void)
+{
+    asm("int3");
+    /* TODO: set errno */
+    return -1;
+}
+
+/* Not implemented */
+int chroot(const char *path)
+{
+    asm("int3");
+    /* TODO: set errno */
+    return -1;
+}
+
+/* No-op */
+unsigned alarm(unsigned seconds)
+{
+    asm("int3");
+    return 0;
+}
+
+#endif /* defined(__AROS__) */
diff -ruN openssh-7.3p1/openbsd-compat/port-aros.h openssh-7.3p1.aros/openbsd-compat/port-aros.h
--- openssh-7.3p1/openbsd-compat/port-aros.h	1970-01-01 01:00:00.000000000 +0100
+++ openssh-7.3p1.aros/openbsd-compat/port-aros.h	2016-08-01 04:01:55.000000000 +0200
@@ -0,0 +1,25 @@
+#ifndef _PORT_AROS_H
+#define _PORT_AROS_H
+
+#ifdef __AROS__
+
+#define USER_PROCESS    (1)
+#define DEAD_PROCESS    (2)
+
+struct utmpx
+{
+    char    ut_user[32];
+    char    ut_line[64];
+    short   ut_type;
+    pid_t   ut_pid;
+};
+
+pid_t fork(void);
+int initgroups(const char *user, gid_t group);
+int setpgrp(pid_t pid, pid_t pgid);
+int chroot(const char *path);
+unsigned alarm(unsigned seconds);
+
+#endif
+
+#endif /* ! _PORT_AROS_H */
diff -ruN openssh-7.3p1/openbsd-compat/readpassphrase.c openssh-7.3p1.aros/openbsd-compat/readpassphrase.c
--- openssh-7.3p1/openbsd-compat/readpassphrase.c	2016-07-28 00:54:27.000000000 +0200
+++ openssh-7.3p1.aros/openbsd-compat/readpassphrase.c	2016-08-01 04:01:55.000000000 +0200
@@ -84,12 +84,16 @@
 	 * Read and write to /dev/tty if available.  If not, read from
 	 * stdin and write to stderr unless a tty is required.
 	 */
+#ifndef __AROS__
 	if ((flags & RPP_STDIN) ||
 	    (input = output = open(_PATH_TTY, O_RDWR)) == -1) {
 		if (flags & RPP_REQUIRE_TTY) {
 			errno = ENOTTY;
 			return(NULL);
 		}
+#else
+	{
+#endif
 		input = STDIN_FILENO;
 		output = STDERR_FILENO;
 	}
diff -ruN openssh-7.3p1/packet.c openssh-7.3p1.aros/packet.c
--- openssh-7.3p1/packet.c	2016-07-28 00:54:27.000000000 +0200
+++ openssh-7.3p1.aros/packet.c	2016-08-14 20:06:00.309920138 +0200
@@ -1503,7 +1503,11 @@
 		if (r == 0)
 			return SSH_ERR_CONN_TIMEOUT;
 		/* Read data from the socket. */
+#ifdef __AROS__
+		len = recv(state->connection_in, buf, sizeof(buf), 0);
+#else
 		len = read(state->connection_in, buf, sizeof(buf));
+#endif
 		if (len == 0) {
 			r = SSH_ERR_CONN_CLOSED;
 			goto out;
@@ -2182,8 +2186,13 @@
 	int r;
 
 	if (len > 0) {
+#ifdef __AROS__
+		len = send(state->connection_out,
+			sshbuf_ptr(state->output), len, 0);
+#else
 		len = write(state->connection_out,
 		    sshbuf_ptr(state->output), len);
+#endif
 		if (len == -1) {
 			if (errno == EINTR || errno == EAGAIN ||
 			    errno == EWOULDBLOCK)
diff -ruN openssh-7.3p1/progressmeter.c openssh-7.3p1.aros/progressmeter.c
--- openssh-7.3p1/progressmeter.c	2016-07-28 00:54:27.000000000 +0200
+++ openssh-7.3p1.aros/progressmeter.c	2016-08-11 19:13:55.001709013 +0200
@@ -222,7 +222,7 @@
 			strlcat(buf, "    ", win_size);
 	}
 
-	atomicio(vwrite, STDOUT_FILENO, buf, win_size - 1);
+	atomicio_loc(vwrite, STDOUT_FILENO, buf, win_size - 1);
 	last_update = now;
 }
 
@@ -263,7 +263,8 @@
 		refresh_progress_meter();
 
 	signal(SIGALRM, update_progress_meter);
-	signal(SIGWINCH, sig_winch);
+//	signal(SIGWINCH, sig_winch);
+	asm("int3");
 	alarm(UPDATE_INTERVAL);
 }
 
@@ -279,7 +280,7 @@
 	if (cur_pos != end_pos)
 		refresh_progress_meter();
 
-	atomicio(vwrite, STDOUT_FILENO, "\n", 1);
+	atomicio_loc(vwrite, STDOUT_FILENO, "\n", 1);
 }
 
 /*ARGSUSED*/
diff -ruN openssh-7.3p1/readpass.c openssh-7.3p1.aros/readpass.c
--- openssh-7.3p1/readpass.c	2016-07-28 00:54:27.000000000 +0200
+++ openssh-7.3p1.aros/readpass.c	2016-08-01 04:01:55.000000000 +0200
@@ -129,6 +129,7 @@
 			debug("read_passphrase: stdin is not a tty");
 			use_askpass = 1;
 		}
+#ifndef __AROS__
 	} else {
 		rppflags |= RPP_REQUIRE_TTY;
 		ttyfd = open(_PATH_TTY, O_RDWR);
@@ -139,6 +140,7 @@
 			    strerror(errno));
 			use_askpass = 1;
 		}
+#endif
 	}
 
 	if ((flags & RP_USE_ASKPASS) && getenv("DISPLAY") == NULL)
diff -ruN openssh-7.3p1/scp.c openssh-7.3p1.aros/scp.c
--- openssh-7.3p1/scp.c	2016-07-28 00:54:27.000000000 +0200
+++ openssh-7.3p1.aros/scp.c	2016-08-11 19:13:15.613472206 +0200
@@ -579,7 +579,7 @@
 		    (long long)sb->st_mtime, (long long)sb->st_atime);
 		fprintf(stderr, "Sending file timestamps: %s", buf);
 	}
-	(void) atomicio(vwrite, fd, buf, strlen(buf));
+	(void) atomicio_net(vwrite, fd, buf, strlen(buf));
 	return (response());
 }
 
@@ -816,7 +816,7 @@
 		    (long long)stb.st_size, last);
 		if (verbose_mode)
 			fmprintf(stderr, "Sending file modes: %s", buf);
-		(void) atomicio(vwrite, remout, buf, strlen(buf));
+		(void) atomicio_net(vwrite, remout, buf, strlen(buf));
 		if (response() < 0)
 			goto next;
 		if ((bp = allocbuf(&buffer, fd, COPY_BUFLEN)) == NULL) {
@@ -834,7 +834,7 @@
 			if (i + (off_t)amt > stb.st_size)
 				amt = stb.st_size - i;
 			if (!haderr) {
-				if ((nr = atomicio(read, fd,
+				if ((nr = atomicio_loc(read, fd,
 				    bp->buf, amt)) != amt) {
 					haderr = errno;
 					memset(bp->buf + nr, 0, amt - nr);
@@ -842,7 +842,7 @@
 			}
 			/* Keep writing after error to retain sync */
 			if (haderr) {
-				(void)atomicio(vwrite, remout, bp->buf, amt);
+				(void)atomicio_net(vwrite, remout, bp->buf, amt);
 				memset(bp->buf, 0, amt);
 				continue;
 			}
@@ -858,7 +858,7 @@
 			fd = -1;
 		}
 		if (!haderr)
-			(void) atomicio(vwrite, remout, "", 1);
+			(void) atomicio_net(vwrite, remout, "", 1);
 		else
 			run_err("%s: %s", name, strerror(haderr));
 		(void) response();
@@ -893,7 +893,7 @@
 	    (u_int) (statp->st_mode & FILEMODEMASK), 0, last);
 	if (verbose_mode)
 		fmprintf(stderr, "Entering directory: %s", path);
-	(void) atomicio(vwrite, remout, path, strlen(path));
+	(void) atomicio_net(vwrite, remout, path, strlen(path));
 	if (response() < 0) {
 		closedir(dirp);
 		return;
@@ -912,7 +912,7 @@
 		source(1, vect);
 	}
 	(void) closedir(dirp);
-	(void) atomicio(vwrite, remout, "E\n", 2);
+	(void) atomicio_net(vwrite, remout, "E\n", 2);
 	(void) response();
 }
 
@@ -951,17 +951,17 @@
 	if (targetshouldbedirectory)
 		verifydir(targ);
 
-	(void) atomicio(vwrite, remout, "", 1);
+	(void) atomicio_net(vwrite, remout, "", 1);
 	if (stat(targ, &stb) == 0 && S_ISDIR(stb.st_mode))
 		targisdir = 1;
 	for (first = 1;; first = 0) {
 		cp = buf;
-		if (atomicio(read, remin, cp, 1) != 1)
+		if (atomicio_net(read, remin, cp, 1) != 1)
 			return;
 		if (*cp++ == '\n')
 			SCREWUP("unexpected <newline>");
 		do {
-			if (atomicio(read, remin, &ch, sizeof(ch)) != sizeof(ch))
+			if (atomicio_net(read, remin, &ch, sizeof(ch)) != sizeof(ch))
 				SCREWUP("lost connection");
 			*cp++ = ch;
 		} while (cp < &buf[sizeof(buf) - 1] && ch != '\n');
@@ -973,7 +973,7 @@
 			if (iamremote == 0) {
 				(void) snmprintf(visbuf, sizeof(visbuf),
 				    NULL, "%s", buf + 1);
-				(void) atomicio(vwrite, STDERR_FILENO,
+				(void) atomicio_loc(vwrite, STDERR_FILENO,
 				    visbuf, strlen(visbuf));
 			}
 			if (buf[0] == '\02')
@@ -982,7 +982,7 @@
 			continue;
 		}
 		if (buf[0] == 'E') {
-			(void) atomicio(vwrite, remout, "", 1);
+			(void) atomicio_net(vwrite, remout, "", 1);
 			return;
 		}
 		if (ch == '\n')
@@ -1018,7 +1018,7 @@
 			if (!cp || *cp++ != '\0' || atime.tv_usec < 0 ||
 			    atime.tv_usec > 999999)
 				SCREWUP("atime.usec not delimited");
-			(void) atomicio(vwrite, remout, "", 1);
+			(void) atomicio_net(vwrite, remout, "", 1);
 			continue;
 		}
 		if (*cp != 'C' && *cp != 'D') {
@@ -1107,7 +1107,7 @@
 bad:			run_err("%s: %s", np, strerror(errno));
 			continue;
 		}
-		(void) atomicio(vwrite, remout, "", 1);
+		(void) atomicio_net(vwrite, remout, "", 1);
 		if ((bp = allocbuf(&buffer, ofd, COPY_BUFLEN)) == NULL) {
 			(void) close(ofd);
 			continue;
@@ -1140,7 +1140,7 @@
 			if (count == bp->cnt) {
 				/* Keep reading so we stay sync'd up. */
 				if (wrerr == NO) {
-					if (atomicio(vwrite, ofd, bp->buf,
+					if (atomicio_loc(vwrite, ofd, bp->buf,
 					    count) != count) {
 						wrerr = YES;
 						wrerrno = errno;
@@ -1152,7 +1152,7 @@
 		}
 		unset_nonblock(remin);
 		if (count != 0 && wrerr == NO &&
-		    atomicio(vwrite, ofd, bp->buf, count) != count) {
+		    atomicio_loc(vwrite, ofd, bp->buf, count) != count) {
 			wrerr = YES;
 			wrerrno = errno;
 		}
@@ -1204,7 +1204,7 @@
 			run_err("%s: %s", np, strerror(wrerrno));
 			break;
 		case NO:
-			(void) atomicio(vwrite, remout, "", 1);
+			(void) atomicio_net(vwrite, remout, "", 1);
 			break;
 		case DISPLAYED:
 			break;
@@ -1220,7 +1220,7 @@
 {
 	char ch, *cp, resp, rbuf[2048], visbuf[2048];
 
-	if (atomicio(read, remin, &resp, sizeof(resp)) != sizeof(resp))
+	if (atomicio_net(read, remin, &resp, sizeof(resp)) != sizeof(resp))
 		lostconn(0);
 
 	cp = rbuf;
@@ -1233,7 +1233,7 @@
 	case 1:		/* error, followed by error msg */
 	case 2:		/* fatal error, "" */
 		do {
-			if (atomicio(read, remin, &ch, sizeof(ch)) != sizeof(ch))
+			if (atomicio_net(read, remin, &ch, sizeof(ch)) != sizeof(ch))
 				lostconn(0);
 			*cp++ = ch;
 		} while (cp < &rbuf[sizeof(rbuf) - 1] && ch != '\n');
@@ -1242,7 +1242,7 @@
 			cp[-1] = '\0';
 			(void) snmprintf(visbuf, sizeof(visbuf),
 			    NULL, "%s\n", rbuf);
-			(void) atomicio(vwrite, STDERR_FILENO,
+			(void) atomicio_loc(vwrite, STDERR_FILENO,
 			    visbuf, strlen(visbuf));
 		}
 		++errs;
diff -ruN openssh-7.3p1/session.c openssh-7.3p1.aros/session.c
--- openssh-7.3p1/session.c	2016-07-28 00:54:27.000000000 +0200
+++ openssh-7.3p1.aros/session.c	2016-08-01 04:01:55.000000000 +0200
@@ -1236,8 +1236,9 @@
 # endif /* HAVE_CYGWIN */
 #endif /* HAVE_LOGIN_CAP */
 
-		snprintf(buf, sizeof buf, "%.200s/%.50s",
-			 _PATH_MAILDIR, pw->pw_name);
+//		snprintf(buf, sizeof buf, "%.200s/%.50s",
+//			 _PATH_MAILDIR, pw->pw_name);
+		asm("int3");
 		child_set_env(&env, &envsize, "MAIL", buf);
 
 		/* Normal systems set SHELL by default. */
diff -ruN openssh-7.3p1/sftp-client.c openssh-7.3p1.aros/sftp-client.c
--- openssh-7.3p1/sftp-client.c	2016-07-28 00:54:27.000000000 +0200
+++ openssh-7.3p1.aros/sftp-client.c	2016-08-11 19:14:19.277854965 +0200
@@ -1320,7 +1320,7 @@
 				fatal("Received more data than asked for "
 				    "%zu > %zu", len, req->len);
 			if ((lseek(local_fd, req->offset, SEEK_SET) == -1 ||
-			    atomicio(vwrite, local_fd, data, len) != len) &&
+			    atomicio_loc(vwrite, local_fd, data, len) != len) &&
 			    !write_error) {
 				write_errno = errno;
 				write_error = 1;
diff -ruN openssh-7.3p1/sshbuf-misc.c openssh-7.3p1.aros/sshbuf-misc.c
--- openssh-7.3p1/sshbuf-misc.c	2016-07-28 00:54:27.000000000 +0200
+++ openssh-7.3p1.aros/sshbuf-misc.c	2016-08-01 04:01:55.000000000 +0200
@@ -28,7 +28,6 @@
 #include <stdio.h>
 #include <limits.h>
 #include <string.h>
-#include <resolv.h>
 #include <ctype.h>
 
 #include "ssherr.h"
diff -ruN openssh-7.3p1/ssh.c openssh-7.3p1.aros/ssh.c
--- openssh-7.3p1/ssh.c	2016-07-28 00:54:27.000000000 +0200
+++ openssh-7.3p1.aros/ssh.c	2016-08-14 19:52:00.046008602 +0200
@@ -1932,6 +1932,9 @@
 	    window, packetmax, CHAN_EXTENDED_WRITE,
 	    "client-session", /*nonblock*/0);
 
+#ifdef __AROS__
+	c->aros_console_mode = 1;
+#endif
 	debug3("ssh_session2_open: channel_new: %d", c->self);
 
 	channel_send_open(c->self);
diff -ruN openssh-7.3p1/sshconnect.c openssh-7.3p1.aros/sshconnect.c
--- openssh-7.3p1/sshconnect.c	2016-07-28 00:54:27.000000000 +0200
+++ openssh-7.3p1.aros/sshconnect.c	2016-08-14 20:12:35.887761605 +0200
@@ -532,7 +532,7 @@
 		xasprintf(&client_version_string, "SSH-%d.%d-%.100s\n",
 		    PROTOCOL_MAJOR_1, minor1, SSH_VERSION);
 	}
-	if (atomicio(vwrite, connection_out, client_version_string,
+	if (atomicio_net(vwrite, connection_out, client_version_string,
 	    strlen(client_version_string)) != strlen(client_version_string))
 		fatal("write: %.100s", strerror(errno));
 	chop(client_version_string);
@@ -592,7 +592,7 @@
 				}
 			}
 
-			len = atomicio(read, connection_in, &buf[i], 1);
+			len = atomicio_net(read, connection_in, &buf[i], 1);
 
 			if (len != 1 && errno == EPIPE)
 				fatal("ssh_exchange_identification: "
diff -ruN openssh-7.3p1/sshd.c openssh-7.3p1.aros/sshd.c
--- openssh-7.3p1/sshd.c	2016-07-28 00:54:27.000000000 +0200
+++ openssh-7.3p1.aros/sshd.c	2016-08-11 19:05:02.862509711 +0200
@@ -437,7 +437,7 @@
 	    options.version_addendum, newline);
 
 	/* Send our protocol version identification. */
-	if (atomicio(vwrite, sock_out, server_version_string,
+	if (atomicio_net(vwrite, sock_out, server_version_string,
 	    strlen(server_version_string))
 	    != strlen(server_version_string)) {
 		logit("Could not write ident string to %s port %d",
@@ -448,7 +448,7 @@
 	/* Read other sides version identification. */
 	memset(buf, 0, sizeof(buf));
 	for (i = 0; i < sizeof(buf) - 1; i++) {
-		if (atomicio(read, sock_in, &buf[i], 1) != 1) {
+		if (atomicio_net(read, sock_in, &buf[i], 1) != 1) {
 			logit("Did not receive identification string "
 			    "from %s port %d",
 			    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));
@@ -477,7 +477,7 @@
 	if (sscanf(client_version_string, "SSH-%d.%d-%[^\n]\n",
 	    &remote_major, &remote_minor, remote_version) != 3) {
 		s = "Protocol mismatch.\n";
-		(void) atomicio(vwrite, sock_out, s, strlen(s));
+		(void) atomicio_net(vwrite, sock_out, s, strlen(s));
 		logit("Bad protocol version identification '%.100s' "
 		    "from %s port %d", client_version_string,
 		    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));
@@ -548,7 +548,7 @@
 
 	if (mismatch) {
 		s = "Protocol major versions differ.\n";
-		(void) atomicio(vwrite, sock_out, s, strlen(s));
+		(void) atomicio_net(vwrite, sock_out, s, strlen(s));
 		close(sock_in);
 		close(sock_out);
 		logit("Protocol major versions differ for %s port %d: "
diff -ruN openssh-7.3p1/sshkey.c openssh-7.3p1.aros/sshkey.c
--- openssh-7.3p1/sshkey.c	2016-07-28 00:54:27.000000000 +0200
+++ openssh-7.3p1.aros/sshkey.c	2016-08-01 04:01:55.000000000 +0200
@@ -43,7 +43,6 @@
 #include <limits.h>
 #include <stdio.h>
 #include <string.h>
-#include <resolv.h>
 #ifdef HAVE_UTIL_H
 #include <util.h>
 #endif /* HAVE_UTIL_H */
diff -ruN openssh-7.3p1/ssh-keygen.c openssh-7.3p1.aros/ssh-keygen.c
--- openssh-7.3p1/ssh-keygen.c	2016-07-28 00:54:27.000000000 +0200
+++ openssh-7.3p1.aros/ssh-keygen.c	2016-08-11 19:07:58.219563984 +0200
@@ -2166,7 +2166,7 @@
 		fatal("Couldn't generate KRL");
 	if ((fd = open(identity_file, O_WRONLY|O_CREAT|O_TRUNC, 0644)) == -1)
 		fatal("open %s: %s", identity_file, strerror(errno));
-	if (atomicio(vwrite, fd, (void *)sshbuf_ptr(kbuf), sshbuf_len(kbuf)) !=
+	if (atomicio_loc(vwrite, fd, (void *)sshbuf_ptr(kbuf), sshbuf_len(kbuf)) !=
 	    sshbuf_len(kbuf))
 		fatal("write %s: %s", identity_file, strerror(errno));
 	close(fd);
diff -ruN openssh-7.3p1/ssh-keyscan.c openssh-7.3p1.aros/ssh-keyscan.c
--- openssh-7.3p1/ssh-keyscan.c	2016-07-28 00:54:27.000000000 +0200
+++ openssh-7.3p1.aros/ssh-keyscan.c	2016-08-11 19:09:13.380015861 +0200
@@ -485,7 +485,7 @@
 		bufsiz = sizeof(buf);
 		cp = buf;
 		while (bufsiz-- &&
-		    (n = atomicio(read, s, cp, 1)) == 1 && *cp != '\n') {
+		    (n = atomicio_loc(read, s, cp, 1)) == 1 && *cp != '\n') {
 			if (*cp == '\r')
 				*cp = '\n';
 			cp++;
@@ -542,7 +542,7 @@
 		confree(s);
 		return;
 	}
-	if (atomicio(vwrite, s, buf, n) != (size_t)n) {
+	if (atomicio_loc(vwrite, s, buf, n) != (size_t)n) {
 		error("write (%s): %s", c->c_name, strerror(errno));
 		confree(s);
 		return;
@@ -566,7 +566,7 @@
 		congreet(s);
 		return;
 	}
-	n = atomicio(read, s, c->c_data + c->c_off, c->c_len - c->c_off);
+	n = atomicio_loc(read, s, c->c_data + c->c_off, c->c_len - c->c_off);
 	if (n == 0) {
 		error("read (%s): %s", c->c_name, strerror(errno));
 		confree(s);
diff -ruN openssh-7.3p1/umac.c openssh-7.3p1.aros/umac.c
--- openssh-7.3p1/umac.c	2016-07-28 00:54:27.000000000 +0200
+++ openssh-7.3p1.aros/umac.c	2016-08-01 04:01:55.000000000 +0200
@@ -91,7 +91,7 @@
 typedef u_int16_t	UINT16; /* 2 byte   */
 typedef u_int32_t	UINT32; /* 4 byte   */
 typedef u_int64_t	UINT64; /* 8 bytes  */
-typedef unsigned int	UWORD;  /* Register */
+typedef unsigned int	UWORDSSH;  /* Register */
 
 /* ---------------------------------------------------------------------- */
 /* --- Constants -------------------------------------------------------- */
@@ -332,7 +332,7 @@
 */
 {
     UINT64 h;
-    UWORD c = dlen / 32;
+    UWORDSSH c = dlen / 32;
     UINT32 *k = (UINT32 *)kp;
     const UINT32 *d = (const UINT32 *)dp;
     UINT32 d0,d1,d2,d3,d4,d5,d6,d7;
@@ -365,7 +365,7 @@
  */
 {
   UINT64 h1,h2;
-  UWORD c = dlen / 32;
+  UWORDSSH c = dlen / 32;
   UINT32 *k = (UINT32 *)kp;
   const UINT32 *d = (const UINT32 *)dp;
   UINT32 d0,d1,d2,d3,d4,d5,d6,d7;
@@ -412,7 +412,7 @@
 */
 {
     UINT64 h1,h2,h3;
-    UWORD c = dlen / 32;
+    UWORDSSH c = dlen / 32;
     UINT32 *k = (UINT32 *)kp;
     const UINT32 *d = (const UINT32 *)dp;
     UINT32 d0,d1,d2,d3,d4,d5,d6,d7;
@@ -467,7 +467,7 @@
 */
 {
     UINT64 h1,h2,h3,h4;
-    UWORD c = dlen / 32;
+    UWORDSSH c = dlen / 32;
     UINT32 *k = (UINT32 *)kp;
     const UINT32 *d = (const UINT32 *)dp;
     UINT32 d0,d1,d2,d3,d4,d5,d6,d7;
@@ -546,11 +546,11 @@
 /* ---------------------------------------------------------------------- */
 
 #if (__LITTLE_ENDIAN__)
-static void endian_convert(void *buf, UWORD bpw, UINT32 num_bytes)
+static void endian_convert(void *buf, UWORDSSH bpw, UINT32 num_bytes)
 /* We endian convert the keys on little-endian computers to               */
 /* compensate for the lack of big-endian memory reads during hashing.     */
 {
-    UWORD iters = num_bytes / bpw;
+    UWORDSSH iters = num_bytes / bpw;
     if (bpw == 4) {
         UINT32 *p = (UINT32 *)buf;
         do {
@@ -639,16 +639,16 @@
 static void zero_pad(UINT8 *p, int nbytes)
 {
 /* Write "nbytes" of zeroes, beginning at "p" */
-    if (nbytes >= (int)sizeof(UWORD)) {
-        while ((ptrdiff_t)p % sizeof(UWORD)) {
+    if (nbytes >= (int)sizeof(UWORDSSH)) {
+        while ((ptrdiff_t)p % sizeof(UWORDSSH)) {
             *p = 0;
             nbytes--;
             p++;
         }
-        while (nbytes >= (int)sizeof(UWORD)) {
-            *(UWORD *)p = 0;
-            nbytes -= sizeof(UWORD);
-            p += sizeof(UWORD);
+        while (nbytes >= (int)sizeof(UWORDSSH)) {
+            *(UWORDSSH *)p = 0;
+            nbytes -= sizeof(UWORDSSH);
+            p += sizeof(UWORDSSH);
         }
     }
     while (nbytes) {
@@ -1043,7 +1043,7 @@
  * hash each one with NH, calling the polyhash on each NH output.
  */
 {
-    UWORD bytes_hashed, bytes_remaining;
+    UWORDSSH bytes_hashed, bytes_remaining;
     UINT64 result_buf[STREAMS];
     UINT8 *nh_result = (UINT8 *)&result_buf;
     
diff -ruN openssh-7.3p1/uuencode.c openssh-7.3p1.aros/uuencode.c
--- openssh-7.3p1/uuencode.c	2016-07-28 00:54:27.000000000 +0200
+++ openssh-7.3p1.aros/uuencode.c	2016-08-01 04:01:55.000000000 +0200
@@ -27,7 +27,6 @@
 
 #include <sys/types.h>
 #include <netinet/in.h>
-#include <resolv.h>
 #include <stdio.h>
 #include <stdlib.h>
 
