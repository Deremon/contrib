diff -ruN SDL-1.2.11/configure SDL-1.2.11-aros/configure
--- SDL-1.2.11/configure	2006-06-27 06:48:54.000000000 +0200
+++ SDL-1.2.11-aros/configure	2009-10-28 18:29:35.000000000 +0100
@@ -485,6 +485,7 @@
 verbose=
 x_includes=NONE
 x_libraries=NONE
+TARGET_LIB_NAME=libSDL
 
 # Installation directory options.
 # These are left unexpanded so users can "make install exec_prefix=/foo"
@@ -731,6 +732,11 @@
   -target=* | --target=* | --targe=* | --targ=* | --tar=* | --ta=* | --t=*)
     target_alias=$ac_optarg ;;
 
+  --target-lib-name)
+    ac_prev=TARGET_LIB_NAME ;;
+  --target-lib-name=*)
+    TARGET_LIB_NAME=$ac_optarg ;;
+
   -v | -verbose | --verbose | --verbos | --verbo | --verb)
     verbose=yes ;;
 
@@ -23553,7 +23559,7 @@
 SOURCES="$SOURCES $srcdir/src/file/*.c"
 SOURCES="$SOURCES $srcdir/src/joystick/*.c"
 SOURCES="$SOURCES $srcdir/src/stdlib/*.c"
-SOURCES="$SOURCES $srcdir/src/thread/*.c"
+# SOURCES="$SOURCES $srcdir/src/thread/*.c"
 SOURCES="$SOURCES $srcdir/src/timer/*.c"
 SOURCES="$SOURCES $srcdir/src/video/*.c"
 
@@ -33095,6 +33101,62 @@
         # The RISC OS platform requires special setup.
         EXTRA_LDFLAGS="$EXTRA_LDFLAGS -ljpeg -ltiff -lpng -lz"
         ;;
+    *-aros)
+        ARCH=amigaos
+        # Set up files for the audio library
+        if test x$enable_audio = xyes; then
+            cat >>confdefs.h <<\_ACEOF
+#define SDL_AUDIO_DRIVER_AHI 1
+_ACEOF
+
+            SOURCES="$SOURCES $srcdir/src/audio/amigaos/*.c"
+            have_audio=yes
+        fi
+        # Set up files for the video library
+        if test x$enable_video = xyes; then
+            cat >>confdefs.h <<\_ACEOF
+#define SDL_VIDEO_DRIVER_CYBERGRAPHICS 1
+_ACEOF
+
+            SOURCES="$SOURCES $srcdir/src/video/cybergfx/*.c"
+            have_video=yes
+        fi
+        # Set up files for the OpenGL support
+        if test x$enable_video_opengl = xyes; then
+            cat >>confdefs.h <<\_ACEOF
+#define SDL_VIDEO_OPENGL 1
+_ACEOF
+
+            video_opengl=yes
+        fi
+        # Set up files for the joystick library
+        if test x$enable_joystick = xyes; then
+            cat >>confdefs.h <<\_ACEOF
+#define SDL_JOYSTICK_AMIGA 1
+_ACEOF
+
+            SOURCES="$SOURCES $srcdir/src/joystick/amigaos/*.c"
+            have_joystick=yes
+        fi
+        # Set up files for the timer library
+        if test x$enable_timers = xyes; then
+            cat >>confdefs.h <<\_ACEOF
+#define SDL_TIMER_AMIGA 1
+_ACEOF
+
+            SOURCES="$SOURCES $srcdir/src/timer/amigaos/*.c"
+            have_timers=yes
+        fi
+        # Set up files for the thread library
+        if test x$enable_threads = xyes; then
+            cat >>confdefs.h <<\_ACEOF
+#define SDL_THREAD_AMIGA 1
+_ACEOF
+
+            SOURCES="$SOURCES $srcdir/src/thread/amigaos/*.c"
+            have_threads=yes
+        fi
+	;;
     *)
         { { echo "$as_me:$LINENO: error:
 *** Unsupported host:  Please add to configure.in
@@ -33933,6 +33995,7 @@
 s,@ENABLE_STATIC_FALSE@,$ENABLE_STATIC_FALSE,;t t
 s,@ac_aux_dir@,$ac_aux_dir,;t t
 s,@INCLUDE@,$INCLUDE,;t t
+s,@TARGET_LIB_NAME@,$TARGET_LIB_NAME,;t t
 s,@SOURCES@,$SOURCES,;t t
 s,@OBJECTS@,$OBJECTS,;t t
 s,@SDLMAIN_SOURCES@,$SDLMAIN_SOURCES,;t t
diff -ruN SDL-1.2.11/include/SDL_config.h SDL-1.2.11-aros/include/SDL_config.h
--- SDL-1.2.11/include/SDL_config.h	2006-06-27 07:05:24.000000000 +0200
+++ SDL-1.2.11-aros/include/SDL_config.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,45 +0,0 @@
-/*
-    SDL - Simple DirectMedia Layer
-    Copyright (C) 1997-2006 Sam Lantinga
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Lesser General Public
-    License as published by the Free Software Foundation; either
-    version 2.1 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public
-    License along with this library; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-
-    Sam Lantinga
-    slouken@libsdl.org
-*/
-
-#ifndef _SDL_config_h
-#define _SDL_config_h
-
-#include "SDL_platform.h"
-
-/* Add any platform that doesn't build using the configure system */
-#if defined(__AMIGA__)
-#include "SDL_config_amiga.h"
-#elif defined(__DREAMCAST__)
-#include "SDL_config_dreamcast.h"
-#elif defined(__MACOS__)
-#include "SDL_config_macos.h"
-#elif defined(__MACOSX__)
-#include "SDL_config_macosx.h"
-#elif defined(__WIN32__)
-#include "SDL_config_win32.h"
-#elif defined(__OS2__)
-#include "SDL_config_os2.h"
-#else
-#include "SDL_config_minimal.h"
-#endif /* platform config */
-
-#endif /* _SDL_config_h */
diff -ruN SDL-1.2.11/Makefile.in SDL-1.2.11-aros/Makefile.in
--- SDL-1.2.11/Makefile.in	2006-06-20 07:49:00.000000000 +0200
+++ SDL-1.2.11-aros/Makefile.in	2009-10-28 18:29:35.000000000 +0100
@@ -30,7 +30,7 @@
 AR	= @AR@
 RANLIB	= @RANLIB@
 
-TARGET  = libSDL.la
+SDL_TARGET  = @TARGET_LIB_NAME@.la
 SOURCES = @SOURCES@
 OBJECTS = @OBJECTS@
 
@@ -46,7 +46,7 @@
 LT_REVISION = @LT_REVISION@
 LT_LDFLAGS  = -no-undefined -rpath $(libdir) -release $(LT_RELEASE) -version-info $(LT_CURRENT):$(LT_REVISION):$(LT_AGE)
 
-all: $(srcdir)/configure Makefile $(objects) $(objects)/$(TARGET) $(objects)/$(SDLMAIN_TARGET)
+all: $(srcdir)/configure Makefile $(objects) $(objects)/$(SDL_TARGET) $(objects)/$(SDLMAIN_TARGET)
 
 $(srcdir)/configure: $(srcdir)/configure.in
 	@echo "Warning, configure.in is out of date"
@@ -71,7 +71,7 @@
 
 include $(depend)
 
-$(objects)/$(TARGET): $(OBJECTS)
+$(objects)/$(SDL_TARGET): $(OBJECTS)
 	$(LIBTOOL) --mode=link $(CC) -o $@ $(OBJECTS) $(LDFLAGS) $(EXTRA_LDFLAGS) $(LT_LDFLAGS)
 
 $(objects)/$(SDLMAIN_TARGET): $(SDLMAIN_OBJECTS)
@@ -91,14 +91,14 @@
 	$(INSTALL) -m 644 include/SDL_config.h $(includedir)/SDL/SDL_config.h
 install-lib:
 	$(SHELL) $(auxdir)/mkinstalldirs $(libdir)
-	$(LIBTOOL) --mode=install $(INSTALL) $(objects)/$(TARGET) $(libdir)/$(TARGET)
+	$(LIBTOOL) --mode=install $(INSTALL) $(objects)/$(SDL_TARGET) $(libdir)/$(SDL_TARGET)
 	$(INSTALL) -m 644 $(objects)/$(SDLMAIN_TARGET) $(libdir)/$(SDLMAIN_TARGET)
 	$(RANLIB) $(libdir)/$(SDLMAIN_TARGET)
 install-data:
 	$(SHELL) $(auxdir)/mkinstalldirs $(datadir)/aclocal
 	$(INSTALL) -m 644 $(srcdir)/sdl.m4 $(datadir)/aclocal/sdl.m4
 	$(SHELL) $(auxdir)/mkinstalldirs $(libdir)/pkgconfig
-	$(INSTALL) -m 644 $(srcdir)/sdl.pc $(libdir)/pkgconfig
+	$(INSTALL) -m 644 sdl.pc $(libdir)/pkgconfig
 install-man:
 	$(SHELL) $(auxdir)/mkinstalldirs $(mandir)/man3
 	for src in $(srcdir)/docs/man3/*.3; do \
@@ -117,7 +117,7 @@
 	rm -f $(includedir)/SDL/SDL_config.h
 	-rmdir $(includedir)/SDL
 uninstall-lib:
-	$(LIBTOOL) --mode=uninstall rm -f $(libdir)/$(TARGET)
+	$(LIBTOOL) --mode=uninstall rm -f $(libdir)/$(SDL_TARGET)
 	rm -f $(libdir)/$(SDLMAIN_TARGET)
 uninstall-data:
 	rm -f $(datadir)/aclocal/sdl.m4
diff -ruN SDL-1.2.11/src/audio/amigaos/mydebug.h SDL-1.2.11-aros/src/audio/amigaos/mydebug.h
--- SDL-1.2.11/src/audio/amigaos/mydebug.h	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.11-aros/src/audio/amigaos/mydebug.h	2009-10-28 18:29:35.000000000 +0100
@@ -0,0 +1,14 @@
+#ifndef MYDEBUG
+
+#ifndef NO_AMIGADEBUG
+#define D(x) x
+#define bug kprintf
+extern void kprintf(const char *,...);
+#else
+#define D(x)
+#endif
+
+#define MAKE_HIT() {char *a=NULL,b;b=*a;}
+
+#define MYDEBUG
+#endif
diff -ruN SDL-1.2.11/src/audio/amigaos/SDL_ahiaudio.c SDL-1.2.11-aros/src/audio/amigaos/SDL_ahiaudio.c
--- SDL-1.2.11/src/audio/amigaos/SDL_ahiaudio.c	2006-05-01 10:02:41.000000000 +0200
+++ SDL-1.2.11-aros/src/audio/amigaos/SDL_ahiaudio.c	2009-10-28 18:29:35.000000000 +0100
@@ -114,7 +114,7 @@
 }
 
 AudioBootStrap AHI_bootstrap = {
-	"AHI", Audio_Available, Audio_CreateDevice
+	"AHI", "AHI SDL driver", Audio_Available, Audio_CreateDevice
 };
 
 
@@ -240,7 +240,11 @@
 
 		case 16: { /* Signed 16 bit audio data */
 			D(bug("Samples a 16 bit...\n"));
+#if AROS_BIG_ENDIAN
 			spec->format = AUDIO_S16MSB;
+#else
+			spec->format = AUDIO_S16LSB;
+#endif
 			this->hidden->bytespersample=2;
 			if(spec->channels<2)
 				this->hidden->type = AHIST_M16S;
diff -ruN SDL-1.2.11/src/audio/amigaos/SDL_ahiaudio.h SDL-1.2.11-aros/src/audio/amigaos/SDL_ahiaudio.h
--- SDL-1.2.11/src/audio/amigaos/SDL_ahiaudio.h	2006-05-01 10:02:41.000000000 +0200
+++ SDL-1.2.11-aros/src/audio/amigaos/SDL_ahiaudio.h	2009-10-28 18:29:35.000000000 +0100
@@ -26,7 +26,7 @@
 
 #include <exec/exec.h>
 #include <dos/dos.h>
-#ifdef __SASC
+#if defined(__SASC) || defined(__AROS__)
 #include <proto/exec.h>
 #else
 #include <inline/exec.h>
diff -ruN SDL-1.2.11/src/audio/SDL_audio.c SDL-1.2.11-aros/src/audio/SDL_audio.c
--- SDL-1.2.11/src/audio/SDL_audio.c	2006-05-09 10:47:05.000000000 +0200
+++ SDL-1.2.11-aros/src/audio/SDL_audio.c	2009-10-28 18:29:35.000000000 +0100
@@ -116,6 +116,7 @@
 void SDL_AudioQuit(void);
 
 #if SDL_AUDIO_DRIVER_AHI
+#include "amigaos/mydebug.h"
 static int audio_configured = 0;
 #endif
 
diff -ruN SDL-1.2.11/src/joystick/amigaos/mydebug.h SDL-1.2.11-aros/src/joystick/amigaos/mydebug.h
--- SDL-1.2.11/src/joystick/amigaos/mydebug.h	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.11-aros/src/joystick/amigaos/mydebug.h	2009-10-28 18:29:35.000000000 +0100
@@ -0,0 +1,14 @@
+#ifndef MYDEBUG
+
+#ifndef NO_AMIGADEBUG
+#define D(x) x
+#define bug kprintf
+extern void kprintf(const char *,...);
+#else
+#define D(x)
+#endif
+
+#define MAKE_HIT() {char *a=NULL,b;b=*a;}
+
+#define MYDEBUG
+#endif
diff -ruN SDL-1.2.11/src/joystick/amigaos/SDL_sysjoystick.c SDL-1.2.11-aros/src/joystick/amigaos/SDL_sysjoystick.c
--- SDL-1.2.11/src/joystick/amigaos/SDL_sysjoystick.c	2006-05-01 10:02:39.000000000 +0200
+++ SDL-1.2.11-aros/src/joystick/amigaos/SDL_sysjoystick.c	2009-10-28 18:29:35.000000000 +0100
@@ -26,7 +26,7 @@
 /* This is the system specific header for the SDL joystick API */
 
 #include <libraries/lowlevel.h>
-#if defined(__SASC) || defined(STORMC4_WOS)
+#if defined(__SASC) || defined(STORMC4_WOS) || defined(__AROS__)
 #include <proto/exec.h>
 #include <proto/lowlevel.h>
 #include <proto/graphics.h>
@@ -40,6 +40,7 @@
 extern struct ExecBase *SysBase;
 extern struct GfxBase *GfxBase;
 
+#include "SDL_events.h"
 #include "SDL_joystick.h"
 #include "../SDL_sysjoystick.h"
 #include "../SDL_joystick_c.h"
@@ -74,7 +75,7 @@
 {
 	if(!LowLevelBase)
 	{
-		if(LowLevelBase=OpenLibrary("lowlevel.library",37))
+		if((LowLevelBase=OpenLibrary("lowlevel.library",37)))
 			return 2;
 	}
 	else
diff -ruN SDL-1.2.11/src/thread/amigaos/mydebug.h SDL-1.2.11-aros/src/thread/amigaos/mydebug.h
--- SDL-1.2.11/src/thread/amigaos/mydebug.h	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.11-aros/src/thread/amigaos/mydebug.h	2009-10-28 18:29:35.000000000 +0100
@@ -0,0 +1,14 @@
+#ifndef MYDEBUG
+
+#ifndef NO_AMIGADEBUG
+#define D(x) x
+#define bug kprintf
+extern void kprintf(const char *,...);
+#else
+#define D(x)
+#endif
+
+#define MAKE_HIT() {char *a=NULL,b;b=*a;}
+
+#define MYDEBUG
+#endif
diff -ruN SDL-1.2.11/src/thread/amigaos/SDL_sysmutex.c SDL-1.2.11-aros/src/thread/amigaos/SDL_sysmutex.c
--- SDL-1.2.11/src/thread/amigaos/SDL_sysmutex.c	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.11-aros/src/thread/amigaos/SDL_sysmutex.c	2009-10-28 18:29:35.000000000 +0100
@@ -0,0 +1,130 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is SDL_free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+/* An implementation of mutexes using semaphores */
+
+#include "SDL_error.h"
+#include "SDL_thread.h"
+#include "SDL_systhread_c.h"
+
+
+struct SDL_mutex {
+	int recursive;
+	Uint32 owner;
+	SDL_sem *sem;
+};
+
+/* Create a mutex */
+SDL_mutex *SDL_CreateMutex(void)
+{
+	SDL_mutex *mutex;
+
+	/* Allocate mutex memory */
+	mutex = (SDL_mutex *)SDL_malloc(sizeof(*mutex));
+	if ( mutex ) {
+		/* Create the mutex semaphore, with initial value 1 */
+		mutex->sem = SDL_CreateSemaphore(1);
+		mutex->recursive = 0;
+		mutex->owner = 0;
+		if ( ! mutex->sem ) {
+			SDL_free(mutex);
+			mutex = NULL;
+		}
+	} else {
+		SDL_OutOfMemory();
+	}
+	return mutex;
+}
+
+/* Free the mutex */
+void SDL_DestroyMutex(SDL_mutex *mutex)
+{
+	if ( mutex ) {
+		if ( mutex->sem ) {
+			SDL_DestroySemaphore(mutex->sem);
+		}
+		SDL_free(mutex);
+	}
+}
+
+/* Lock the semaphore */
+int SDL_mutexP(SDL_mutex *mutex)
+{
+#ifdef DISABLE_THREADS
+	return 0;
+#else
+	Uint32 this_thread;
+
+	if ( mutex == NULL ) {
+		SDL_SetError("Passed a NULL mutex");
+		return -1;
+	}
+
+	this_thread = SDL_ThreadID();
+	if ( mutex->owner == this_thread ) {
+		++mutex->recursive;
+	} else {
+		/* The order of operations is important.
+		   We set the locking thread id after we obtain the lock
+		   so unlocks from other threads will fail.
+		*/
+		SDL_SemWait(mutex->sem);
+		mutex->owner = this_thread;
+		mutex->recursive = 0;
+	}
+
+	return 0;
+#endif /* DISABLE_THREADS */
+}
+
+/* Unlock the mutex */
+int SDL_mutexV(SDL_mutex *mutex)
+{
+#ifdef DISABLE_THREADS
+	return 0;
+#else
+	if ( mutex == NULL ) {
+		SDL_SetError("Passed a NULL mutex");
+		return -1;
+	}
+
+	/* If we don't own the mutex, we can't unlock it */
+	if ( SDL_ThreadID() != mutex->owner ) {
+		SDL_SetError("mutex not owned by this thread");
+		return -1;
+	}
+
+	if ( mutex->recursive ) {
+		--mutex->recursive;
+	} else {
+		/* The order of operations is important.
+		   First reset the owner so another thread doesn't lock
+		   the mutex and set the ownership before we reset it,
+		   then release the lock semaphore.
+		 */
+		mutex->owner = 0;
+		SDL_SemPost(mutex->sem);
+	}
+	return 0;
+#endif /* DISABLE_THREADS */
+}
diff -ruN SDL-1.2.11/src/thread/amigaos/SDL_systhread.c SDL-1.2.11-aros/src/thread/amigaos/SDL_systhread.c
--- SDL-1.2.11/src/thread/amigaos/SDL_systhread.c	2006-05-01 10:02:48.000000000 +0200
+++ SDL-1.2.11-aros/src/thread/amigaos/SDL_systhread.c	2009-11-07 11:41:07.000000000 +0100
@@ -40,7 +40,7 @@
 
 #if defined(__SASC) && !defined(__PPC__) 
 __saveds __asm Uint32 RunThread(register __a0 char *args )
-#elif defined(__PPC__)
+#elif defined(__PPC__) || defined(__AROS__)
 Uint32 RunThread(char *args)
 #else
 Uint32 __saveds RunThread(char *args __asm("a0") )
@@ -115,7 +115,7 @@
 	thread->handle=(struct Task *)CreateNewProcTags(NP_Output,Output(),
 					NP_Name,(ULONG)"SDL subtask",
 					NP_CloseOutput, FALSE,
-					NP_StackSize,20000,
+					NP_StackSize, 98304,
 					NP_Entry,(ULONG)RunThread,
 					args ? NP_Arguments : TAG_IGNORE,(ULONG)buffer,
 					TAG_DONE);
diff -ruN SDL-1.2.11/src/thread/amigaos/SDL_systhread_c.h SDL-1.2.11-aros/src/thread/amigaos/SDL_systhread_c.h
--- SDL-1.2.11/src/thread/amigaos/SDL_systhread_c.h	2006-05-01 10:02:48.000000000 +0200
+++ SDL-1.2.11-aros/src/thread/amigaos/SDL_systhread_c.h	2009-10-28 18:29:35.000000000 +0100
@@ -24,7 +24,7 @@
 #include <exec/exec.h>
 #include <dos/dos.h>
 #include <dos/dostags.h>
-#if defined (__SASC) || defined(STORMC4_WOS)
+#if defined (__SASC) || defined(STORMC4_WOS) || defined(__AROS__)
 #include <proto/dos.h>
 #include <proto/exec.h>
 #else
diff -ruN SDL-1.2.11/src/timer/amigaos/mydebug.h SDL-1.2.11-aros/src/timer/amigaos/mydebug.h
--- SDL-1.2.11/src/timer/amigaos/mydebug.h	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.11-aros/src/timer/amigaos/mydebug.h	2009-10-28 18:29:35.000000000 +0100
@@ -0,0 +1,14 @@
+#ifndef MYDEBUG
+
+#ifndef NO_AMIGADEBUG
+#define D(x) x
+#define bug kprintf
+extern void kprintf(const char *,...);
+#else
+#define D(x)
+#endif
+
+#define MAKE_HIT() {char *a=NULL,b;b=*a;}
+
+#define MYDEBUG
+#endif
diff -ruN SDL-1.2.11/src/timer/amigaos/SDL_systimer.c SDL-1.2.11-aros/src/timer/amigaos/SDL_systimer.c
--- SDL-1.2.11/src/timer/amigaos/SDL_systimer.c	2006-05-01 10:02:36.000000000 +0200
+++ SDL-1.2.11-aros/src/timer/amigaos/SDL_systimer.c	2009-10-28 18:29:35.000000000 +0100
@@ -23,6 +23,9 @@
 
 #ifdef SDL_TIMER_AMIGA
 
+#define __TIMER_NOLIBBASE__          
+#define __GRAPHICS_NOLIBBASE__
+
 #include <stdio.h>
 #include <time.h>
 #include <signal.h>
@@ -36,7 +39,7 @@
 #include <pragmas/graphics.h>
 #include <clib/exec_protos.h>
 #include <pragmas/exec.h>
-#elif defined(STORMC4_WOS)
+#elif defined(STORMC4_WOS) || defined(__AROS__)
 #include <proto/dos.h>
 #include <proto/exec.h>
 #include <proto/graphics.h>
@@ -56,29 +59,124 @@
 
 /* The first ticks value of the application */
 
-#if !defined(__PPC__) || defined(STORMC4_WOS) || defined(MORPHOS)
+#if defined (__AROS__) || !defined(__PPC__) || defined(MORPHOS)
 static clock_t start;
 
+#define USE_SYSTIME
+
+#ifdef USE_SYSTIME
+#include <devices/timer.h>
+#include <proto/timer.h>
+
+static struct timerequest *TimerIO = NULL;
+static struct Device *TimerBase = NULL;
+static struct timeval basetime;
+static struct MsgPort     *TimerMP = NULL;
+
+static int fallback = 0;
+
+static void close_timer(void)
+{
+    D(bug("freeing timer resources..."));
+    if(TimerIO) {
+        CloseDevice((struct IORequest *)TimerIO);
+        DeleteIORequest((struct IORequest *)TimerIO);
+        TimerIO = NULL;
+    }
+    if(TimerMP) {
+        DeleteMsgPort(TimerMP);
+        TimerMP = NULL;
+    }
+    D(bug("OK\n"));
+}
+
+static BOOL open_timer(void)
+{
+  if (TimerBase || fallback) {
+     return FALSE;
+  }
+
+  if (!(TimerMP = CreateMsgPort())) {
+ 	 start=clock();
+     fallback = 1;
+     return FALSE;
+  }
+
+  if (!(TimerIO = (struct timerequest *)
+              CreateIORequest(TimerMP, sizeof(struct timerequest)))) {
+     DeleteMsgPort(TimerMP);
+	 start=clock();
+     fallback = 1;
+     return FALSE;
+  }
+
+  if (OpenDevice("timer.device", UNIT_VBLANK, &TimerIO->tr_node, 0)) {
+      DeleteMsgPort(TimerMP);
+      DeleteIORequest((struct IORequest *)TimerIO);
+ 	  start=clock();
+      fallback = 1;
+      return FALSE;
+  }
+
+  TimerBase = TimerIO->tr_node.io_Device;
+  D(bug("Timer resource allocated.\n"));
+
+  return TRUE;
+}
+
+#endif
+
 void SDL_StartTicks(void)
 {
+#ifndef USE_SYSTIME
 	/* Set first ticks value */
 	start=clock();
+#else
+  if (open_timer()) {
+    GetSysTime(&basetime);
+    D(bug("Basetime: %lusecs %lumicro\n", basetime.tv_secs, basetime.tv_micro));
+
+#ifndef SHARED_LIB
+    atexit(close_timer);
+#endif
+  }
+#endif
 }
 
 Uint32 SDL_GetTicks (void)
 {
-	clock_t ticks;
-
-	ticks=clock()-start;
-
-#ifdef __SASC
-// CLOCKS_PER_SEC == 1000 !
+#ifdef USE_SYSTIME
+    open_timer(); // TimerBase must be set for GetSysTime()
+    if (fallback) {
+#endif
+        clock_t ticks;
+        
+        ticks=clock()-start;
 
-	return(ticks);
+#if CLOCKS_PER_SEC == 1000
+        return(ticks);
 #else
-// CLOCKS_PER_SEC != 1000 !
+        return ticks*(1000/CLOCKS_PER_SEC);
+#endif  
 
-	return ticks*(1000/CLOCKS_PER_SEC);
+#ifdef USE_SYSTIME
+    }
+    else {
+        struct timeval tv;
+        Uint32 tics;
+        
+        GetSysTime(&tv);
+
+        if(basetime.tv_micro > tv.tv_micro) {           
+           tv.tv_secs --;
+          
+           tv.tv_micro += 1000000;
+        }
+        tics = ((tv.tv_secs - basetime.tv_secs) * 1000) + 
+            ((tv.tv_micro - basetime.tv_micro)/1000);
+
+        return tics;
+    }
 #endif
 }
 
@@ -88,14 +186,20 @@
 
 	if(ms<50)
 	{
+#ifndef USE_SYSTIME
 		clock_t to_wait=clock();
-
-#ifndef __SASC
+// most archs have clocks per sec == 1000
+#if CLOCKS_PER_SEC != 1000
 		ms*=(CLOCKS_PER_SEC/1000);
 #endif
 		to_wait+=ms;
 
 		while(clock()<to_wait);
+#else
+        Uint32 to_wait = SDL_GetTicks() + ms;
+
+        while(SDL_GetTicks() < to_wait);
+#endif
 	}
 	else
 	{
diff -ruN SDL-1.2.11/src/video/cybergfx/mydebug.h SDL-1.2.11-aros/src/video/cybergfx/mydebug.h
--- SDL-1.2.11/src/video/cybergfx/mydebug.h	1970-01-01 01:00:00.000000000 +0100
+++ SDL-1.2.11-aros/src/video/cybergfx/mydebug.h	2009-10-28 18:29:35.000000000 +0100
@@ -0,0 +1,14 @@
+#ifndef MYDEBUG
+
+#ifndef NO_AMIGADEBUG
+#define D(x) x
+#define bug kprintf
+extern void kprintf(const char *,...);
+#else
+#define D(x)
+#endif
+
+#define MAKE_HIT() {char *a=NULL,b;b=*a;}
+
+#define MYDEBUG
+#endif
diff -ruN SDL-1.2.11/src/video/cybergfx/SDL_amigaevents.c SDL-1.2.11-aros/src/video/cybergfx/SDL_amigaevents.c
--- SDL-1.2.11/src/video/cybergfx/SDL_amigaevents.c	2006-05-01 10:02:46.000000000 +0200
+++ SDL-1.2.11-aros/src/video/cybergfx/SDL_amigaevents.c	2009-11-07 18:02:58.000000000 +0100
@@ -37,7 +37,7 @@
 
 /* The translation tables from an Amiga keysym to a SDL keysym */
 static SDLKey MISC_keymap[256];
-SDL_keysym *amiga_TranslateKey(int code, SDL_keysym *keysym);
+SDL_keysym *amiga_TranslateKey(int code, UWORD qualifier, SDL_keysym *keysym);
 struct IOStdReq *ConReq=NULL;
 struct MsgPort *ConPort=NULL;
 
@@ -189,13 +189,32 @@
 
 	    case IDCMP_RAWKEY:
 
+			/* Mouse wheel support */
+			if (code == RAWKEY_NM_WHEEL_UP)
+			{
+				posted = SDL_PrivateMouseButton(SDL_PRESSED,
+							SDL_BUTTON_WHEELUP, 0, 0);
+				posted |= SDL_PrivateMouseButton(SDL_RELEASED,
+							SDL_BUTTON_WHEELUP, 0, 0);
+				break;
+			}
+			
+			if (code == RAWKEY_NM_WHEEL_DOWN)
+			{
+				posted = SDL_PrivateMouseButton(SDL_PRESSED,
+							SDL_BUTTON_WHEELDOWN, 0, 0);
+				posted |= SDL_PrivateMouseButton(SDL_RELEASED,
+							SDL_BUTTON_WHEELDOWN, 0, 0);
+				break;
+			}
+
 		    /* Key press? */
 
 		    if( !(code&IECODE_UP_PREFIX) )
 		    {
 				SDL_keysym keysym;
 				posted = SDL_PrivateKeyboard(SDL_PRESSED,
-					amiga_TranslateKey(code, &keysym));
+					amiga_TranslateKey(code, msg->Qualifier, &keysym));
 		    }
 		    else
 		    {
@@ -208,7 +227,7 @@
 /*			if ( ! X11_KeyRepeat(SDL_Display, &xevent) )  */
 
 				posted = SDL_PrivateKeyboard(SDL_RELEASED,
-					amiga_TranslateKey(code, &keysym));
+					amiga_TranslateKey(code, msg->Qualifier, &keysym));
 		    }
 		    break;
 	    /* Have we been iconified? */
@@ -291,7 +310,7 @@
 
 	/* Keep processing pending events */
 	pending = 0;
-	while ( m=(struct IntuiMessage *)GetMsg(SDL_Window->UserPort) ) {
+	while (( m=(struct IntuiMessage *)GetMsg(SDL_Window->UserPort) )) {
 		amiga_DispatchEvent(this,m);
 		++pending;
 	}
@@ -423,8 +442,12 @@
 	MISC_keymap[95] = SDLK_HELP;
 }
 
-SDL_keysym *amiga_TranslateKey(int code, SDL_keysym *keysym)
+SDL_keysym *amiga_TranslateKey(int code, UWORD qualifier, SDL_keysym *keysym)
 {
+	struct InputEvent event;
+	long actual;
+	char buffer[5];
+
 	#ifdef STORMC4_WOS
 	static struct Library *KeymapBase=NULL; /* Linking failed in WOS version if ConsoleDevice was used */
 	#else
@@ -438,49 +461,44 @@
 #ifdef DEBUG_KEYS
 	fprintf(stderr, "Translating key 0x%.4x (%d)\n", xsym, xkey->keycode);
 #endif
-	/* Get the translated SDL virtual keysym */
-	if ( keysym->sym==SDLK_UNKNOWN )
+	#ifdef STORMC4_WOS
+	if(!KeymapBase)
+	#else
+	if(!ConsoleDevice)
+	#endif
 	{
 		#ifdef STORMC4_WOS
-		if(!KeymapBase)
+		KeymapBase=OpenLibrary("keymap.library", 0L);
 		#else
-		if(!ConsoleDevice)
-		#endif
+		if((ConPort=CreateMsgPort()))
 		{
-			#ifdef STORMC4_WOS
-			KeymapBase=OpenLibrary("keymap.library", 0L);
-			#else
-			if(ConPort=CreateMsgPort())
+			if((ConReq=CreateIORequest(ConPort,sizeof(struct IOStdReq))))
 			{
-				if(ConReq=CreateIORequest(ConPort,sizeof(struct IOStdReq)))
-				{
-					if(!OpenDevice("console.device",-1,(struct IORequest *)ConReq,0))
-						ConsoleDevice=(struct Library *)ConReq->io_Device;
-					else
-					{
-						DeleteIORequest(ConReq);
-						ConReq=NULL;
-					}
-				}
+				if(!OpenDevice("console.device",-1,(struct IORequest *)ConReq,0))
+					ConsoleDevice=(struct Library *)ConReq->io_Device;
 				else
 				{
-					DeleteMsgPort(ConPort);
-					ConPort=NULL;
+					DeleteIORequest(ConReq);
+					ConReq=NULL;
 				}
 			}
-			#endif
+			else
+			{
+				DeleteMsgPort(ConPort);
+				ConPort=NULL;
+			}
 		}
-
+		#endif
+	}
+	/* Get the translated SDL virtual keysym */
+	if ( keysym->sym==SDLK_UNKNOWN )
+	{
 		#ifdef STORMC4_WOS
 		if(KeymapBase)
 		#else
 		if(ConsoleDevice)
 		#endif
 		{
-			struct InputEvent event;
-			long actual;
-			char buffer[5];
-
 			event.ie_Qualifier=0;
 			event.ie_Class=IECLASS_RAWKEY;
 			event.ie_SubClass=0L;
@@ -504,7 +522,7 @@
 				{
 					keysym->sym=*buffer;
 					D(bug("Converted rawcode %ld to <%lc>\n",code,*buffer));
-// Bufferizzo x le successive chiamate!
+					// Bufferizzo x le successive chiamate!
 					MISC_keymap[code]=*buffer;
 				}
 			}
@@ -516,12 +534,20 @@
 	/* If UNICODE is on, get the UNICODE value for the key */
 	keysym->unicode = 0;
 	if ( SDL_TranslateUNICODE ) {
+		event.ie_Class = IECLASS_RAWKEY;
+		event.ie_SubClass = 0;
+		event.ie_Code  = code & ~(IECODE_UP_PREFIX);
+		event.ie_Qualifier = qualifier;
+		event.ie_EventAddress = NULL;
+
+		actual = RawKeyConvert(&event, buffer, 5, 0);
+		if (actual == 1) keysym->unicode = buffer[0];
 #if 0
 		static XComposeStatus state;
 		/* Until we handle the IM protocol, use XLookupString() */
 		unsigned char keybuf[32];
 		if ( XLookupString(xkey, (char *)keybuf, sizeof(keybuf),
-							NULL, &state) ) {
+					NULL, &state) ) {
 			keysym->unicode = keybuf[0];
 		}
 #endif
diff -ruN SDL-1.2.11/src/video/cybergfx/SDL_cgxgl.c SDL-1.2.11-aros/src/video/cybergfx/SDL_cgxgl.c
--- SDL-1.2.11/src/video/cybergfx/SDL_cgxgl.c	2006-05-01 10:02:46.000000000 +0200
+++ SDL-1.2.11-aros/src/video/cybergfx/SDL_cgxgl.c	2009-10-28 18:29:35.000000000 +0100
@@ -21,32 +21,32 @@
 */
 #include "SDL_config.h"
 
-/* StormMesa implementation of SDL OpenGL support */
+/* AROSMesa implementation of SDL OpenGL support */
 
 #include "SDL_cgxgl_c.h"
 #include "SDL_cgxvideo.h"
 
 #if SDL_VIDEO_OPENGL
-AmigaMesaContext glcont=NULL;
+AROSMesaContext glcont=NULL;
 #endif
 
 /* Init OpenGL */
 int CGX_GL_Init(_THIS)
 {
 #if SDL_VIDEO_OPENGL
-   int i = 0;
+	LONG i = 0;
 	struct TagItem attributes [ 14 ]; /* 14 should be more than enough :) */
-   struct Window *win = (struct Window *)SDL_Window;
+	struct Window *win = (struct Window *)SDL_Window;
 
-	// default config. Always used...
+	/* default config. Always used... */
 	attributes[i].ti_Tag = AMA_Window;	attributes[i++].ti_Data = (unsigned long)win;
 	attributes[i].ti_Tag = AMA_Left;		attributes[i++].ti_Data = 0;
 	attributes[i].ti_Tag = AMA_Bottom;	attributes[i++].ti_Data = 0;
 	attributes[i].ti_Tag = AMA_Width;	attributes[i++].ti_Data = win->Width-win->BorderLeft-win->BorderRight;
 	attributes[i].ti_Tag = AMA_Height;	attributes[i++].ti_Data = win->Height-win->BorderBottom-win->BorderTop;
-	attributes[i].ti_Tag = AMA_DirectRender; attributes[i++].ti_Data = GL_TRUE;
+	/* attributes[i].ti_Tag = AMA_DirectRender; attributes[i++].ti_Data = GL_TRUE; */ /*NOT SUPPORTED */
 
-	// double buffer ?
+	/* double buffer ? */
 	attributes[i].ti_Tag = AMA_DoubleBuf;
 	if ( this->gl_config.double_buffer ) {
 		attributes[i++].ti_Data = GL_TRUE;
@@ -54,7 +54,8 @@
 	else {
 		attributes[i++].ti_Data = GL_FALSE;
 	}
-	// RGB(A) Mode ?
+	
+	/* RGB(A) Mode ? */
 	attributes[i].ti_Tag = AMA_RGBMode;
 	if ( this->gl_config.red_size   != 0 &&
 	     this->gl_config.blue_size  != 0 &&
@@ -64,27 +65,29 @@
 	else {
 		attributes[i++].ti_Data = GL_FALSE;
 	}
-	// no depth buffer ?
+    
+	/* no depth buffer ? */
 	if ( this->gl_config.depth_size == 0 ) {
 		attributes[i].ti_Tag = AMA_NoDepth;
 		attributes[i++].ti_Data = GL_TRUE;
 	}
-	// no stencil buffer ?
+	/* no stencil buffer ? */
 	if ( this->gl_config.stencil_size == 0 ) {
 		attributes[i].ti_Tag = AMA_NoStencil;
 		attributes[i++].ti_Data = GL_TRUE;
 	}
-	// no accum buffer ?
+	/* no accum buffer ? */
 	if ( this->gl_config.accum_red_size   != 0 &&
 	     this->gl_config.accum_blue_size  != 0 &&
 	     this->gl_config.accum_green_size != 0 ) {
 		attributes[i].ti_Tag = AMA_NoAccum;
 		attributes[i++].ti_Data = GL_TRUE;
 	}
-	// done...
+    
+	/* done */
 	attributes[i].ti_Tag	= TAG_DONE;
 
-	glcont = AmigaMesaCreateContext(attributes);
+	glcont = AROSMesaCreateContext(attributes);
 	if ( glcont == NULL ) {
 		SDL_SetError("Couldn't create OpenGL context");
 		return(-1);
@@ -104,7 +107,7 @@
 {
 #if SDL_VIDEO_OPENGL
 	if ( glcont != NULL ) {
-		AmigaMesaDestroyContext(glcont);
+		AROSMesaDestroyContext(glcont);
 		glcont = NULL;
 		this->gl_data->gl_active = 0;
 		this->gl_config.driver_loaded = 0;
@@ -124,7 +127,9 @@
 	tags[0].ti_Tag = AMA_Window;
 	tags[0].ti_Data = (unsigned long)win;
 	tags[1].ti_Tag = TAG_DONE;
-	AmigaMesaSetRast(glcont, tags);
+    
+    /* AROSMesa does not support this */
+    //AROSMesaSetRast(glcont, tags);
 
 	return 0;
 #else
@@ -141,13 +146,13 @@
 	if(glcont == NULL)
 		return -1;
 
-	AmigaMesaMakeCurrent(glcont, glcont->buffer);
+	AROSMesaMakeCurrent(glcont);
 	return 0;
 }
 
 void CGX_GL_SwapBuffers(_THIS)
 {
-	AmigaMesaSwapBuffers(glcont);
+	AROSMesaSwapBuffers(glcont);
 }
 
 int CGX_GL_GetAttribute(_THIS, SDL_GLattr attrib, int* value) {
@@ -191,13 +196,14 @@
 			return -1;
 	}
 
-	AmigaMesaGetConfig(glcont->visual, mesa_attrib, value);
+    /* AROSMesa does not support this */
+	//AROSMesaGetConfig(glcont->visual, mesa_attrib, value);
 	return 0;
 }
 
 void *CGX_GL_GetProcAddress(_THIS, const char *proc) {
 	void *func = NULL;
-	func = AmiGetGLProc(proc);
+	func = AROSMesaGetProcAddress(proc);
 	return func;
 }
 
diff -ruN SDL-1.2.11/src/video/cybergfx/SDL_cgxgl_c.h SDL-1.2.11-aros/src/video/cybergfx/SDL_cgxgl_c.h
--- SDL-1.2.11/src/video/cybergfx/SDL_cgxgl_c.h	2006-05-01 10:02:46.000000000 +0200
+++ SDL-1.2.11-aros/src/video/cybergfx/SDL_cgxgl_c.h	2009-10-28 18:29:35.000000000 +0100
@@ -21,15 +21,14 @@
 */
 #include "SDL_config.h"
 
-/* StormMesa implementation of SDL OpenGL support */
+/* AROSMesa implementation of SDL OpenGL support */
 
 #include "../SDL_sysvideo.h"
 
 #define _THIS   SDL_VideoDevice *_this
 
 #if SDL_VIDEO_OPENGL
-#include <GL/Amigamesa.h>
-extern void *AmiGetGLProc(const char *proc);
+#include <GL/arosmesa.h>
 #endif /* SDL_VIDEO_OPENGL */
 
 struct SDL_PrivateGLData {
diff -ruN SDL-1.2.11/src/video/cybergfx/SDL_cgximage.c SDL-1.2.11-aros/src/video/cybergfx/SDL_cgximage.c
--- SDL-1.2.11/src/video/cybergfx/SDL_cgximage.c	2006-05-01 10:02:46.000000000 +0200
+++ SDL-1.2.11-aros/src/video/cybergfx/SDL_cgximage.c	2009-10-28 18:29:35.000000000 +0100
@@ -28,8 +28,15 @@
 #include <kstat.h>
 #endif
 
+// this is an undocumented feature of CGX, and recently of AROS
+// and P96, if it's not defined let define it ourselves.
+ 
+#ifndef RECTFMT_RAW
+    #define RECTFMT_RAW        (5UL)
+#endif
+
 #ifdef USE_CGX_WRITELUTPIXEL
-#if defined(__SASC) || defined(__PPC__)
+#if defined(__SASC) || defined(__PPC__) || defined(__AROS__)
 	#define WLUT WriteLUTPixelArray
 #else
 void WLUT(APTR a,UWORD b,UWORD c,UWORD d,struct RastPort *e,APTR f,UWORD g,UWORD h,UWORD i,UWORD l,UBYTE m)
@@ -45,64 +52,83 @@
 BOOL SafeDisp=TRUE,SafeChange=TRUE;
 struct MsgPort *safeport=NULL,*dispport=NULL;
 ULONG safe_sigbit,disp_sigbit;
-int use_picasso96=1;
+int use_picasso96 = 0;
 
 int CGX_SetupImage(_THIS, SDL_Surface *screen)
 {
-	SDL_Ximage=NULL;
+    SDL_Ximage = NULL;
 
-	if(screen->flags&SDL_HWSURFACE) {
-		ULONG pitch;
+    if(screen->flags & SDL_HWSURFACE) {
+        ULONG pitch;
+        APTR pixels;
+        APTR lock;
 
-		if(!screen->hwdata) {
-			if(!(screen->hwdata=SDL_malloc(sizeof(struct private_hwdata))))
-				return -1;
+        lock = LockBitMapTags(
+                SDL_RastPort->BitMap,
+                LBMI_BASEADDRESS, (IPTR)&pixels,
+                LBMI_BYTESPERROW, (IPTR)&pitch,
+                TAG_DONE);
 
-			D(bug("Creating system accel struct\n"));
-		}
-		screen->hwdata->lock=NULL;
-		screen->hwdata->allocated=0;
-		screen->hwdata->mask=NULL;
-		screen->hwdata->bmap=SDL_RastPort->BitMap;
-		screen->hwdata->videodata=this;
-
-		if(!(screen->hwdata->lock=LockBitMapTags(screen->hwdata->bmap,
-				LBMI_BASEADDRESS,(ULONG)&screen->pixels,
-				LBMI_BYTESPERROW,(ULONG)&pitch,TAG_DONE))) {
-			SDL_free(screen->hwdata);
-			screen->hwdata=NULL;
-			return -1;
-		}
-		else {
-			UnLockBitMap(screen->hwdata->lock);
-			screen->hwdata->lock=NULL;
-		}
+        if (lock) {
+            UnLockBitMap(lock);		
 
-		screen->pitch=pitch;
+            if (!screen->hwdata)
+                screen->hwdata = SDL_malloc(sizeof(struct private_hwdata));
 
-		this->UpdateRects = CGX_FakeUpdate;
+            if (screen->hwdata) {
+                screen->hwdata->lock      = NULL;
+                screen->hwdata->allocated = 0;
+                screen->hwdata->mask      = NULL;
+                screen->hwdata->bmap      = SDL_RastPort->BitMap;
+                screen->hwdata->videodata = this;
 
-		D(bug("Accel video image configured (%lx, pitch %ld).\n",screen->pixels,screen->pitch));
-		return 0;
-	}
 
-	screen->pixels = SDL_malloc(screen->h*screen->pitch);
+// FA: pixels is NOT guaranteed to stay the same across
+// the various LockBitMap() calls. This oughta be fixed.	    
 
-	if ( screen->pixels == NULL ) {
-		SDL_OutOfMemory();
-		return(-1);
-	}
+// GG: NOT true, screen->pixels is set up in EVERY SDL_LockSurface
+// call.
+                screen->pixels = pixels;    
+                screen->pitch  = pitch;
 
-	SDL_Ximage=screen->pixels;
+                this->UpdateRects = CGX_FakeUpdate;
 
-	if ( SDL_Ximage == NULL ) {
-		SDL_SetError("Couldn't create XImage");
-		return(-1);
-	}
+                D(bug("Accel video image configured (%lx, pitch %ld).\n", screen->pixels, screen->pitch));
 
-	this->UpdateRects = CGX_NormalUpdate;
+                return 0;
+            }
 
-	return(0);
+            D(bug("Creating system accel struct FAILED.\n"));
+        }
+
+        D(bug("HW surface not available, falling back to SW surface.\n"));
+
+        screen->flags &= ~SDL_HWSURFACE;
+    }
+
+    screen->hwdata=NULL;
+
+    D(bug("h = %d, pitch = %d\n", screen->h, screen->pitch));
+
+    screen->pixels = SDL_malloc(screen->h*screen->pitch);
+
+    if ( screen->pixels == NULL )
+    {
+        SDL_OutOfMemory();
+        return -1;
+    }
+
+    SDL_Ximage = screen->pixels;
+
+    if ( SDL_Ximage == NULL )
+    {
+        SDL_SetError("Couldn't create XImage");
+        return -1;
+    }
+
+    this->UpdateRects = CGX_NormalUpdate;
+
+    return 0;
 }
 
 void CGX_DestroyImage(_THIS, SDL_Surface *screen)
@@ -131,7 +157,7 @@
 {
 	int retval;
 
-	D(bug("Calling ResizeImage()\n"));
+	D(bug("Calling ResizeImage(%lx,%lx)\n",this,screen));
 
 	CGX_DestroyImage(this, screen);
 
@@ -146,6 +172,7 @@
 			}
 		}
 	}
+
 	return(retval);
 }
 
@@ -170,7 +197,7 @@
 	surface->hwdata->videodata=this;
 	surface->hwdata->allocated=0;
 
-	if(surface->hwdata->bmap=AllocBitMap(surface->w,surface->h,this->hidden->depth,BMF_MINPLANES,SDL_Display->RastPort.BitMap))
+	if((surface->hwdata->bmap=AllocBitMap(surface->w,surface->h,this->hidden->depth,BMF_MINPLANES,SDL_Display->RastPort.BitMap)))
 	{
 		surface->hwdata->allocated=1;
 		surface->flags|=SDL_HWSURFACE;
@@ -252,7 +279,7 @@
 		{
 			Wait(disp_sigbit);
 // Non faccio nulla, vuoto solo la porta
-			while(GetMsg(dispport)!=NULL) 
+			while(GetMsg(dispport)!=NULL)
 				;
 			SafeChange=TRUE;
 		}
@@ -268,7 +295,7 @@
 		if(!SafeDisp)
 		{
 			Wait(safe_sigbit);
-			while(GetMsg(safeport)!=NULL) 
+			while(GetMsg(safeport)!=NULL)
 				;
 			SafeDisp=TRUE;
 		}
@@ -416,14 +443,14 @@
 
 				customroutine=2;
 #endif
-				
+
 //				format=RECTFMT_LUT8;   Vecchia funzione x usare la WritePixelArray.
 			}
 			else
 				customroutine=1;
 			break;
 		default:
-			D(bug("Unable to blit this surface!\n"));	
+			D(bug("Unable to blit this surface!\n"));
 			return;
 	}
 
@@ -449,6 +476,7 @@
 			if ( ! rects[i].w ) { /* Clipped? */
 				continue;
 			}
+//			WLPA(this->screen,&rects[i],SDL_RastPort,SDL_XPixels,SDL_Window);
 
 			WLUT(this->screen->pixels,rects[i].x, rects[i].y,this->screen->pitch,
 					SDL_RastPort,SDL_XPixels,SDL_Window->BorderLeft+rects[i].x,SDL_Window->BorderTop+rects[i].y,
@@ -474,7 +502,7 @@
 			else
 				destbase=bm_address+(SDL_Window->TopEdge+SDL_Window->BorderTop)*destpitch+(SDL_Window->BorderLeft+SDL_Window->LeftEdge)*this->hidden->BytesPerPixel;
 
-			for ( i=0; i<numrects; ++i ) 
+			for ( i=0; i<numrects; ++i )
 			{
 				srcwidth=rects[i].w;
 
@@ -486,7 +514,7 @@
 				dest+=(rects[i].y*destpitch);
 				src=((char *)(this->screen->pixels))+rects[i].x;
 				src+=(rects[i].y*this->screen->pitch);
-				
+
 				for(j=rects[i].h;j;--j)
 				{
 					dst=dest;
@@ -620,8 +648,8 @@
 
 //		D(bug("Using customroutine!\n"));
 
-		if(handle=LockBitMapTags(SDL_RastPort->BitMap,LBMI_BASEADDRESS,(ULONG)&bm_address,
-								LBMI_BYTESPERROW,(ULONG)&destpitch,TAG_DONE))
+		if((handle=LockBitMapTags(SDL_RastPort->BitMap,LBMI_BASEADDRESS,(ULONG)&bm_address,
+								LBMI_BYTESPERROW,(ULONG)&destpitch,TAG_DONE)))
 		{
 			unsigned char *destbase;
 			register int j,srcwidth;
@@ -863,9 +891,9 @@
 		Uint32	destpitch;
 		APTR handle;
 
-		if(handle=LockBitMapTags(SDL_RastPort->BitMap,
+		if((handle=LockBitMapTags(SDL_RastPort->BitMap,
 					LBMI_BASEADDRESS,(ULONG)&bm_address,
-					LBMI_BYTESPERROW,(ULONG)&destpitch,TAG_DONE))
+					LBMI_BYTESPERROW,(ULONG)&destpitch,TAG_DONE)))
 		{
 			register int j;
 			register unsigned char *src,*dest;
diff -ruN SDL-1.2.11/src/video/cybergfx/SDL_cgxmodes.c SDL-1.2.11-aros/src/video/cybergfx/SDL_cgxmodes.c
--- SDL-1.2.11/src/video/cybergfx/SDL_cgxmodes.c	2006-05-01 10:02:46.000000000 +0200
+++ SDL-1.2.11-aros/src/video/cybergfx/SDL_cgxmodes.c	2009-10-28 18:29:35.000000000 +0100
@@ -208,7 +208,7 @@
     int i;
     for(i = 0; i < this->hidden->nvisuals; i++)
 	{
-		if(this->hidden->visuals[i].depth == format->BitsPerPixel) // Era bpp
+		if(this->hidden->visuals[i].depth == format->BitsPerPixel || this->hidden->visuals[i].bpp == format->BitsPerPixel) // Era bpp
 		    return 1;
 	}
     return 0;
diff -ruN SDL-1.2.11/src/video/cybergfx/SDL_cgxvideo.c SDL-1.2.11-aros/src/video/cybergfx/SDL_cgxvideo.c
--- SDL-1.2.11/src/video/cybergfx/SDL_cgxvideo.c	2006-05-01 10:02:46.000000000 +0200
+++ SDL-1.2.11-aros/src/video/cybergfx/SDL_cgxvideo.c	2009-10-28 18:29:35.000000000 +0100
@@ -53,8 +53,10 @@
 /* CGX driver bootstrap functions */
 
 struct Library *CyberGfxBase=NULL;
+#ifndef __AROS__
 struct IntuitionBase *IntuitionBase=NULL;
 struct GfxBase *GfxBase=NULL;
+#endif
 
 int CGX_SetGamma(_THIS, float red, float green, float blue)
 {
@@ -109,6 +111,7 @@
 		if(this->hidden->dbuffer)
 		{
 			extern struct MsgPort *safeport,*dispport;
+			D(bug("Freeing double buffering stuff..."));
 
 			this->hidden->dbuffer=0;
 
@@ -123,8 +126,8 @@
 				DeleteMsgPort(dispport);
 			}
 
-			this->hidden->SB[0]->sb_DBufInfo->dbi_SafeMessage.mn_ReplyPort=this->hidden->SB[0]->sb_DBufInfo->dbi_DispMessage.mn_ReplyPort=NULL;
-			this->hidden->SB[1]->sb_DBufInfo->dbi_SafeMessage.mn_ReplyPort=this->hidden->SB[1]->sb_DBufInfo->dbi_DispMessage.mn_ReplyPort=NULL;
+			this->hidden->SB[0]->sb_DBufInfo->dbi_SafeMessage.mn_ReplyPort = this->hidden->SB[0]->sb_DBufInfo->dbi_DispMessage.mn_ReplyPort=NULL;
+			this->hidden->SB[1]->sb_DBufInfo->dbi_SafeMessage.mn_ReplyPort = this->hidden->SB[1]->sb_DBufInfo->dbi_DispMessage.mn_ReplyPort=NULL;
 
 			if(this->hidden->SB[1])
 				FreeScreenBuffer(SDL_Display,this->hidden->SB[1]);
@@ -139,6 +142,7 @@
 
 			SDL_RastPort=NULL;
 		}
+		D(bug("Closing screen..."));
 		CloseScreen(GFX_Display);
 		currently_fullscreen=0;
 	}
@@ -146,6 +150,7 @@
 		UnlockPubScreen(NULL,GFX_Display);
 
 	GFX_Display = NULL;
+	D(bug("Ok\n"));
 }
 
 static int CGX_Available(void)
@@ -253,129 +258,154 @@
 	"CGX", "AmigaOS CyberGraphics", CGX_Available, CGX_CreateDevice
 };
 
+#include <aros/macros.h>
+
+#warning FIXME: Endianess issues here. Temporarily used AROS_BE2WORD() to get around them
 Uint32 MakeBitMask(_THIS,int type,int format,int *bpp)
 {
-	D(if(type==0)bug("REAL pixel format: "));
-
-	if(this->hidden->depth==*bpp)
-	{
+	if (this->hidden->depth==*bpp)  {
+		D(if(type==0)bug("REAL pixel format: "));
 
-	switch(format)
-    	{
-		case PIXFMT_LUT8:
-			D(if(type==0)bug("LUT8\n"));
-			return 0;
-		case PIXFMT_BGR15:
-		case PIXFMT_RGB15PC:
-			switch(type)
-			{
-				case 0:
-					D(bug("RGB15PC/BGR15\n"));
-					return 31;
-				case 1:
-					return 992;
-				case 2:
-					return 31744;
-			}
-		case PIXFMT_RGB15:
-		case PIXFMT_BGR15PC:
-			switch(type)
-			{
-				case 0:
-					D(bug("RGB15/BGR15PC\n"));
-					return 31744;
-				case 1:
-					return 992;
-				case 2:
-					return 31;
-			}
-		case PIXFMT_BGR16PC:
-		case PIXFMT_RGB16:
-			switch(type)
-			{
-				case 0:
-					D(bug("RGB16PC\n"));
-					return 63488;
-				case 1:
-					return 2016;
-				case 2:
-					return 31;
-			}
-		case PIXFMT_BGR16:
-		case PIXFMT_RGB16PC:
-			switch(type)
-			{
-				case 0:
-					D(bug("RGB16PC/BGR16\n"));
-					return 31;
-				case 1:
-					return 2016;
-				case 2:
-					return 63488;
-			}
+		switch(format) {
+			case PIXFMT_LUT8:
+				D(if(type==0)bug("LUT8\n"));
+				return 0;
+			case PIXFMT_BGR15:
+				switch(type) {
+					case 0:
+						D(bug("BGR15\n"));
+						return AROS_BE2WORD(0x001f);
+					case 1:
+						return AROS_BE2WORD(0x03e0);
+					case 2:
+						return AROS_BE2WORD(0x7c00);
+				}
+			case PIXFMT_RGB15:
+				switch(type) {
+					case 0:
+						D(bug("RGB15\n"));
+						return AROS_BE2WORD(0x7c00);
+					case 1:
+						return AROS_BE2WORD(0x03e0);
+					case 2:
+						return AROS_BE2WORD(0x001f);
+				}
+			case PIXFMT_RGB15PC:
+				switch(type) {
+					case 0:
+						D(bug("RGB15PC\n"));
+						return AROS_BE2WORD(0x007c);
+					case 1:
+						return AROS_BE2WORD(0xe003);
+					case 2:
+						return AROS_BE2WORD(0x1f00);
+				}
+			case PIXFMT_BGR15PC:
+				switch(type) {
+					case 0:
+						D(bug("BGR15PC\n"));
+						return AROS_BE2WORD(0x1f00);
+					case 1:
+						return AROS_BE2WORD(0xe003);
+					case 2:
+						return AROS_BE2WORD(0x007c);
+				}
+			case PIXFMT_RGB16:
+				switch(type) {
+					case 0:
+						D(bug("RGB16\n"));
+						return AROS_BE2WORD(0xf800);
+					case 1:
+						return AROS_BE2WORD(0x07e0);
+					case 2:
+						return AROS_BE2WORD(0x001f);
+				}
+			case PIXFMT_BGR16:
+				switch(type) {
+					case 0:
+						D(bug("BGR16\n"));
+						return AROS_BE2WORD(0x001f);
+					case 1:
+						return AROS_BE2WORD(0x07e0);
+					case 2:
+						return AROS_BE2WORD(0xf800);
+				}
+			case PIXFMT_RGB16PC:
+				switch(type) {
+					case 0:
+						D(bug("RGB16PC\n"));
+						return AROS_BE2WORD(0x00f8);
+					case 1:
+						return AROS_BE2WORD(0xe007);
+					case 2:
+						return AROS_BE2WORD(0x1f00);
+				}
+			case PIXFMT_BGR16PC:
+				switch(type) {
+					case 0:
+						D(bug("BGR16PC\n"));
+						return AROS_BE2WORD(0x1f00);
+					case 1:
+						return AROS_BE2WORD(0xe007);
+					case 2:
+						return AROS_BE2WORD(0x00f8);
+				}
 
-		case PIXFMT_RGB24:
-			switch(type)
-			{
-				case 0:
-					D(bug("RGB24/BGR24\n"));
-					return 0xff0000;
-				case 1:
-					return 0xff00;
-				case 2:
-					return 0xff;
-			}
-		case PIXFMT_BGR24:
-			switch(type)
-			{
-				case 0:
-					D(bug("BGR24\n"));
-					return 0xff;
-				case 1:
-					return 0xff00;
-				case 2:
-					return 0xff0000;
-			}
-		case PIXFMT_ARGB32:
-			switch(type)
-			{
-				case 0:
-					D(bug("ARGB32\n"));
-					return 0xff0000;
-				case 1:
-					return 0xff00;
-				case 2:
-					return 0xff;
-			}
-		case PIXFMT_BGRA32:
-			switch(type)
-			{
-				case 0:
-					D(bug("BGRA32\n"));
-					return 0xff00;
-				case 1:
-					return 0xff0000;
-				case 2:
-					return 0xff000000;
-			}
-		case PIXFMT_RGBA32:
-			switch(type)
-			{
-				case 0:
-					D(bug("RGBA32\n"));
-					return 0xff000000;
-				case 1:
-					return 0xff0000;
-				case 2:
-					return 0xff00;
-			}
-		default:
-			D(bug("Unknown pixel format! Default to 24bit\n"));
-			return (Uint32) (255<<(type*8));
-	}
-	}
-	else
-	{
+			case PIXFMT_RGB24:
+				switch(type) {
+					case 0:
+						D(bug("RGB24/BGR24\n"));
+						return AROS_BE2LONG(0x00ff0000);
+					case 1:
+						return AROS_BE2LONG(0x0000ff00);
+					case 2:
+						return AROS_BE2LONG(0x000000ff);
+				}
+			case PIXFMT_BGR24:
+				switch(type) {
+					case 0:
+						D(bug("BGR24\n"));
+						return AROS_BE2LONG(0x000000ff);
+					case 1:
+						return AROS_BE2LONG(0x0000ff00);
+					case 2:
+						return AROS_BE2LONG(0x00ff0000);
+				}
+			case PIXFMT_ARGB32:
+				switch(type) {
+					case 0:
+						D(bug("ARGB32\n"));
+						return AROS_BE2LONG(0x00ff0000);
+					case 1:
+						return AROS_BE2LONG(0x0000ff00);
+					case 2:
+						return AROS_BE2LONG(0x000000ff);
+				}
+			case PIXFMT_BGRA32:
+				switch(type) {
+					case 0:
+						D(bug("BGRA32\n"));
+						return AROS_BE2LONG(0xff000000);
+					case 1:
+						return AROS_BE2LONG(0x00ff0000);
+					case 2:
+						return AROS_BE2LONG(0x0000ff00);
+				}
+			case PIXFMT_RGBA32:
+				switch(type) {
+					case 0:
+						D(bug("RGBA32\n"));
+						return AROS_BE2LONG(0x0000ff00);
+					case 1:
+						return AROS_BE2LONG(0x00ff0000);
+					case 2:
+						return AROS_BE2LONG(0xff000000);
+				}
+			default:
+				D(bug("Unknown pixel format! Default to 24bit\n"));
+				return (Uint32) (255<<(type*8));
+		}
+	} else {
 		D(if(type==0)bug("DIFFERENT from screen.\nAllocated screen format: "));
 
 		switch(*bpp)
@@ -394,6 +424,7 @@
 				break;
 			case 24:
 use_truecolor:
+
 				switch(type)
 				{
 					case 0:
@@ -408,11 +439,11 @@
 			case 15:
 				D(if(type==0) bug("Not supported, switching to 24bit!\n"));
 				*bpp=24;
-				goto use_truecolor;
+				return MakeBitMask(this, type, format, bpp);
 				break;
 			default:
 				D(if(type==0)bug("This is a chunky display\n"));
-// For chunky display mask is always 0;
+				// For chunky display mask is always 0;
 				return 0;
 		}
 	}
@@ -422,7 +453,9 @@
 static int CGX_VideoInit(_THIS, SDL_PixelFormat *vformat)
 {
 	int i;
+#ifndef __AROS__
 	struct Library *RTGBase;
+#endif
 
 	D(bug("VideoInit... Opening libraries\n"));
 
@@ -447,12 +480,14 @@
 		}
 	}
 
+#ifndef __AROS__
 	if(RTGBase=OpenLibrary("libs:picasso96/rtg.library",0L)) {
 		extern int use_picasso96;
 
 		CloseLibrary(RTGBase);
 		use_picasso96=1;
 	}
+#endif
 
 	D(bug("Library intialized, locking screen...\n"));
 
@@ -508,11 +543,11 @@
 	swap_pixels = 0;
 
 // Non e' detto che sia cosi' pero', alcune schede potrebbero gestire i modi in modo differente
-
+#if 0
 	if ( SDL_BYTEORDER == SDL_LIL_ENDIAN ) {
 		swap_pixels = 1;
 	}
-
+#endif
 	D(bug("Before GetVideoModes....\n"));
 
 	/* Get the available video modes */
@@ -538,22 +573,7 @@
 	vformat->BitsPerPixel = this->hidden->visuals[i].depth; /* this->hidden->visuals[i].bpp; */
 
 	{
-		int form;
-		APTR handle;
-		struct DisplayInfo info;
-
-		if(!(handle=FindDisplayInfo(this->hidden->visuals[i].visual)))
-		{
-			D(bug("Unable to get visual info...\n"));
-			return -1;
-		}
-
-		if(!GetDisplayInfoData(handle,(char *)&info,sizeof(struct DisplayInfo),DTAG_DISP,NULL)) {
-			D(bug("Unable to get visual info data...\n"));
-			return -1;
-		}
-
-		form=GetCyberIDAttr(CYBRIDATTR_PIXFMT,SDL_Visual);
+		int form = GetCyberIDAttr(CYBRIDATTR_PIXFMT,SDL_Visual);
 
 // In this case I use makebitmask in a way that I'm sure I'll get PIXFMT pixel mask
 
@@ -566,8 +586,8 @@
 	}
 
 	/* See if we have been passed a window to use */
-/*	SDL_windowid = SDL_getenv("SDL_WINDOWID"); */
-	SDL_windowid=NULL;
+	SDL_windowid = SDL_getenv("SDL_WINDOWID");
+//	SDL_windowid=NULL;
 
 	/* Create the blank cursor */
 	SDL_BlankCursor = AllocMem(16,MEMF_CHIP|MEMF_CLEAR);
@@ -578,7 +598,7 @@
 	this->info.blit_hw_CC = 1;
 	this->info.blit_sw = 1;
 	this->info.blit_fill = 1;
-	this->info.video_mem=2000000; // Not always true but almost any Amiga card has this memory!
+	this->info.video_mem=2000; // Not always true but almost any Amiga card has this memory!
 
 	this->hidden->same_format=0;
 	SDL_RastPort=&SDL_Display->RastPort;
@@ -607,36 +627,32 @@
 //			CGX_LeaveFullScreen(this); tolto x crash
 		}
 
-		/* Destroy the output window */
-		if ( SDL_Window ) {
-			CloseWindow(SDL_Window);
-			SDL_Window=NULL;
-		}
-
 		/* Free the colormap entries */
 		if ( SDL_XPixels ) {
-			int numcolors;
-			unsigned long pixel;
-
-			if(this->screen->format&&this->hidden->depth==8&&!was_fullscreen)
+			if(this->screen && this->hidden && GFX_Display && this->screen->format&&this->hidden->depth==8&&!was_fullscreen)
 			{
-				numcolors = 1<<this->screen->format->BitsPerPixel;
+				int numcolors = 1<<this->screen->format->BitsPerPixel;
+				unsigned long pixel;
 
 				if(numcolors>256)
 					numcolors=256;
 
-				if(!was_fullscreen&&this->hidden->depth==8)
+				D(bug("Releasing %d pens...\n", numcolors));
+				for ( pixel=0; pixel<numcolors; pixel++ )
 				{
-					for ( pixel=0; pixel<numcolors; pixel++ )
-					{
-						if(SDL_XPixels[pixel]>=0)
-							ReleasePen(GFX_Display->ViewPort.ColorMap,SDL_XPixels[pixel]);
-					}
+					if(SDL_XPixels[pixel]>=0)
+						ReleasePen(GFX_Display->ViewPort.ColorMap,SDL_XPixels[pixel]);
 				}
 			}
 			SDL_free(SDL_XPixels);
 			SDL_XPixels = NULL;
 		}
+
+		/* Destroy the output window */
+		if ( SDL_Window ) {
+			CloseWindow(SDL_Window);
+			SDL_Window=NULL;
+		}
 	}
 }
 
@@ -664,11 +680,9 @@
 int CGX_CreateWindow(_THIS, SDL_Surface *screen,
 			    int w, int h, int bpp, Uint32 flags)
 {
-#if 0
-	int i, depth;
-	Uint32 vis;
-#endif
-	D(bug("CGX_CreateWindow\n"));
+	Uint32 form, rb, gb, bb;
+
+	D(bug("CGX_CreateWindow %dx%d/%d flags:%lx\n", w, h, bpp, flags));
 
 	/* If a window is already present, destroy it and start fresh */
 	if ( SDL_Window ) {
@@ -682,75 +696,36 @@
 		SDL_Window = 0;
 	}
 
-	/* find out which visual we are going to use */
-#if 0
-/* questo l'ho spostato nell'apertura dello schermo, in quanto su Amiga le finestre
-   hanno il pixel mode degli schermi.
- */
-	/*if ( flags & SDL_OPENGL ) {
-		SDL_SetError("OpenGL not supported by the Amiga SDL!");
-		return -1;
-	}
-	else {*/
-		for ( i = 0; i < this->hidden->nvisuals; i++ ) {
-			if ( this->hidden->visuals[i].depth == bpp ) /* era .depth */
-				break;
-		}
-		if ( i == this->hidden->nvisuals ) {
-			SDL_SetError("No matching visual for requested depth");
-			return -1;	/* should never happen */
-		}
-		vis = this->hidden->visuals[i].visual;
-		depth = this->hidden->visuals[i].depth;
-//	}
-	SDL_Visual = vis;
-	this->hidden->depth = depth;
-	D(bug("Setting screen depth to: %ld\n",this->hidden->depth));
-#endif
-
 	/* Allocate the new pixel format for this video mode */
-	{
-		Uint32 form;
-		APTR handle;
-		struct DisplayInfo info;
-
-		if(!(handle=FindDisplayInfo(SDL_Visual)))
-			return -1;
-
-		if(!GetDisplayInfoData(handle,(char *)&info,sizeof(struct DisplayInfo),DTAG_DISP,NULL))
-			return -1;
 
-		form=GetCyberIDAttr(CYBRIDATTR_PIXFMT,SDL_Visual);
+	form=GetCyberIDAttr(CYBRIDATTR_PIXFMT,SDL_Visual);
 
-		if(flags&SDL_HWSURFACE)
+	if(flags&SDL_HWSURFACE)
+	{
+		if(bpp!=this->hidden->depth)
 		{
-			if(bpp!=this->hidden->depth)
-			{
-				bpp=this->hidden->depth;
-				D(bug("Accel forces bpp to be equal (%ld)\n",bpp));
-			}
+			bpp=this->hidden->depth;
+			D(bug("Accel forces bpp to be equal (%ld)\n",bpp));
 		}
+	}
 
-		D(bug("BEFORE screen allocation: bpp:%ld (real:%ld)\n",bpp,this->hidden->depth));
+	D(bug("BEFORE screen allocation: bpp:%ld (real:%ld)\n",bpp,this->hidden->depth));
 
+#ifdef notdef
 /* With this call if needed I'll revert the wanted bpp to a bpp best suited for the display, actually occurs
    only with requested format 15/16bit and display format != 15/16bit
  */
+	rb = MakeBitMask(this,0,form,&bpp);
+	gb = MakeBitMask(this,1,form,&bpp);
+	bb = MakeBitMask(this,2,form,&bpp);
 
-		if ( ! SDL_ReallocFormat(screen, bpp,
-				MakeBitMask(this,0,form,&bpp), MakeBitMask(this,1,form,&bpp), MakeBitMask(this,2,form,&bpp), 0) )
-			return -1;
-
-		D(bug("AFTER screen allocation: bpp:%ld (real:%ld)\n",bpp,this->hidden->depth));
+	if ( ! SDL_ReallocFormat(screen, 8 * GetCyberMapAttr(SDL_Display->RastPort.BitMap,CYBRMATTR_BPPIX), rb, gb, bb, 0) )
+		return -1;
 
-	}
+	D(bug("AFTER screen allocation: bpp:%ld (real:%ld)\n",bpp,this->hidden->depth));
+#endif
 
 	/* Create the appropriate colormap */
-/*
-	if ( SDL_XColorMap != SDL_DisplayColormap ) {
-		XFreeColormap(SDL_Display, SDL_XColorMap);
-	}
-*/
 	if ( GetCyberMapAttr(SDL_Display->RastPort.BitMap,CYBRMATTR_PIXFMT)==PIXFMT_LUT8 || bpp==8 ) {
 	    int ncolors,i;
 	    D(bug("XPixels palette allocation...\n"));
@@ -786,38 +761,37 @@
 	/* Create (or use) the X11 display window */
 
 	if ( !SDL_windowid ) {
-			if( flags & SDL_FULLSCREEN )
-			{
-				SDL_Window = OpenWindowTags(NULL,WA_Width,w,WA_Height,h,
-											WA_Flags,WFLG_ACTIVATE|WFLG_RMBTRAP|WFLG_BORDERLESS|WFLG_BACKDROP|WFLG_REPORTMOUSE,
-											WA_IDCMP,IDCMP_RAWKEY|IDCMP_MOUSEBUTTONS|IDCMP_MOUSEMOVE,
-											WA_CustomScreen,(ULONG)SDL_Display,
-											TAG_DONE);
+		if( flags & SDL_FULLSCREEN ) {
+			SDL_Window = OpenWindowTags(NULL,WA_Width,w,WA_Height,h,
+					WA_Flags,WFLG_ACTIVATE|WFLG_RMBTRAP|WFLG_BORDERLESS|WFLG_BACKDROP|WFLG_REPORTMOUSE,
+					WA_IDCMP,IDCMP_RAWKEY|IDCMP_MOUSEBUTTONS|IDCMP_MOUSEMOVE,
+					WA_CustomScreen,(ULONG)SDL_Display,
+					TAG_DONE);
 
-				D(bug("Opening backdrop window %ldx%ld on display %lx!\n",w,h,SDL_Display));
+			D(bug("Opening backdrop window %ldx%ld on display %lx!\n",w,h,SDL_Display));
+		}
+		else
+		{
+			/* Create GimmeZeroZero window when OpenGL is used */
+			unsigned long gzz = FALSE;
+			if( flags & SDL_OPENGL ) {
+				gzz = TRUE;
 			}
-			else
-			{
-				/* Create GimmeZeroZero window when OpenGL is used */
-				unsigned long gzz = FALSE;
-				if( flags & SDL_OPENGL ) {
-					gzz = TRUE;
-				}
 
-				SDL_Window = OpenWindowTags(NULL,WA_InnerWidth,w,WA_InnerHeight,h,
-											WA_Flags,WFLG_REPORTMOUSE|WFLG_ACTIVATE|WFLG_RMBTRAP | ((flags&SDL_NOFRAME) ? 0 : (WFLG_DEPTHGADGET|WFLG_CLOSEGADGET|WFLG_DRAGBAR | ((flags&SDL_RESIZABLE) ? WFLG_SIZEGADGET|WFLG_SIZEBBOTTOM : 0))),
-											WA_IDCMP,IDCMP_RAWKEY|IDCMP_CLOSEWINDOW|IDCMP_MOUSEBUTTONS|IDCMP_NEWSIZE|IDCMP_MOUSEMOVE,
-											WA_PubScreen,(ULONG)SDL_Display,
-											WA_GimmeZeroZero, gzz,
-														TAG_DONE);
-				D(bug("Opening WB window of size: %ldx%ld!\n",w,h));
-			}
+			SDL_Window = OpenWindowTags(NULL,WA_InnerWidth,w,WA_InnerHeight,h,
+					WA_Flags,WFLG_REPORTMOUSE|WFLG_ACTIVATE|WFLG_RMBTRAP | ((flags&SDL_NOFRAME) ? 0 : (WFLG_DEPTHGADGET|WFLG_CLOSEGADGET|WFLG_DRAGBAR | ((flags&SDL_RESIZABLE) ? WFLG_SIZEGADGET|WFLG_SIZEBBOTTOM : 0))),
+					WA_IDCMP,IDCMP_RAWKEY|IDCMP_CLOSEWINDOW|IDCMP_MOUSEBUTTONS|IDCMP_NEWSIZE|IDCMP_MOUSEMOVE,
+					WA_PubScreen,(ULONG)SDL_Display,
+					WA_GimmeZeroZero, gzz,
+					TAG_DONE);
+			D(bug("Opening WB window of size: %ldx%ld!\n",w,h));
+		}
 
 		if(!SDL_Window)
 			return -1;
 	}
 
-	this->hidden->BytesPerPixel=GetCyberMapAttr(SDL_Window->RPort->BitMap,CYBRMATTR_BPPIX);
+	this->hidden->BytesPerPixel = GetCyberMapAttr(SDL_Window->RPort->BitMap,CYBRMATTR_BPPIX);
 
 	if(screen->flags & SDL_DOUBLEBUF)
 	{
@@ -836,15 +810,10 @@
 
 	if( !SDL_windowid ) {
 	    CGX_SetSizeHints(this, w, h, flags);
+	    this->info.current_w = w;
+	    this->info.current_h = h;
 	}
 
-	/* Set our colormaps when not setting a GL mode */
-/*
-	if ( ! (flags & SDL_OPENGL) ) {
-		XSetWindowColormap(SDL_Display, SDL_Window, SDL_XColorMap);
-	}
-*/
-
 	/* Map them both and go fullscreen, if requested */
 	if ( ! SDL_windowid ) {
 		if ( flags & SDL_FULLSCREEN ) {
@@ -875,6 +844,8 @@
 				screen->flags |= SDL_OPENGL;
 		}
 	}
+    
+    return 0;
 }
 
 int CGX_ResizeWindow(_THIS,
@@ -885,6 +856,8 @@
 	if ( ! SDL_windowid ) {
 		/* Resize the window manager window */
 		CGX_SetSizeHints(this, w, h, flags);
+		this->info.current_w = w;
+		this->info.current_h = h;
 
 		ChangeWindowBox(SDL_Window,SDL_Window->LeftEdge,SDL_Window->TopEdge, w+SDL_Window->BorderLeft+SDL_Window->BorderRight,
 					h+SDL_Window->BorderTop+SDL_Window->BorderBottom);
@@ -894,7 +867,8 @@
 		screen->pitch = SDL_CalculatePitch(screen);
 		CGX_ResizeImage(this, screen, flags);
 	}
-	return(0);
+
+	return 0;
 }
 
 static SDL_Surface *CGX_SetVideoMode(_THIS, SDL_Surface *current,
@@ -903,15 +877,19 @@
 	Uint32 saved_flags;
 	int needcreate=0;
 
-	D(bug("CGX_SetVideoMode current:%lx\n",current));
+	D(bug("CGX_SetVideoMode current:%lx, bpp:%ld, flags:%lx\n",current, bpp, flags));
 
 	/* Lock the event thread, in multi-threading environments */
 	SDL_Lock_EventThread();
 
 // Check if the window needs to be closed or can be resized
 
-	if( (flags&SDL_FULLSCREEN) || (current && current->flags&SDL_FULLSCREEN && !(flags&SDL_FULLSCREEN)))
+	if( (flags&SDL_FULLSCREEN) || (current && current->flags&SDL_FULLSCREEN && !(flags&SDL_FULLSCREEN))) {
+		if (current)
+			D(bug("Discovered we need to re-create window, flags:%lx, current:%lx\n", flags, current->flags));
+
 		needcreate=1;
+	}
 
 // Check if we need to close an already existing videomode...
 
@@ -947,9 +925,9 @@
 		if ( SDL_windowid ) {
 			flags &= ~SDL_FULLSCREEN;
 		}
-		else if(current && current->flags&SDL_FULLSCREEN ) {
-			if(current->w!=width ||
-				current->h!=height ||
+		else if (current && current->flags&SDL_FULLSCREEN ) {
+			if (current->w != width ||
+				current->h != height ||
 				(this->hidden && this->hidden->depth!=bpp))
 			{
 				D(bug("Deleting previous window...\n"));
@@ -969,7 +947,7 @@
 
 			GFX_Display=NULL;
 
-			D(bug("Opening screen...\n"));
+			D(bug("Opening screen %dx%d/%d (id:%lx)...\n", width, height, bpp, okid));
 
 			if(okid!=INVALID_ID)
 				GFX_Display=OpenScreenTags(NULL,
@@ -980,24 +958,28 @@
 								SA_DisplayID,okid,
 								TAG_DONE);
 
-			if(!GFX_Display) {
+			if (!GFX_Display) {
+				D(bug("OpenScreenTags failed!\n"));
 				GFX_Display=SDL_Display;
 				flags &= ~SDL_FULLSCREEN;
 				flags &= ~SDL_DOUBLEBUF;
 			}
 			else {
-				UnlockPubScreen(NULL,SDL_Display);
+				/*
+				if (SDL_Display)
+					UnlockPubScreen(NULL,SDL_Display);
+				*/
 				SDL_Display=GFX_Display;
 	
-				D(bug("Screen opened.\n"));
+				D(bug("Screen opened: %d x %d.\n", GFX_Display->Width, GFX_Display->Height));
 
 				if(flags&SDL_DOUBLEBUF) {
 					int ok=0;
 					D(bug("Start of DBuffering allocations...\n"));
 
-					if(this->hidden->SB[0]=AllocScreenBuffer(SDL_Display,NULL,SB_SCREEN_BITMAP)) {
+					if((this->hidden->SB[0]=AllocScreenBuffer(SDL_Display,NULL,SB_SCREEN_BITMAP))) {
 
-						if(this->hidden->SB[1]=AllocScreenBuffer(SDL_Display,NULL,0L)) {
+						if((this->hidden->SB[1]=AllocScreenBuffer(SDL_Display,NULL,0L))) {
 							extern struct MsgPort *safeport,*dispport;
 
 							safeport=CreateMsgPort();
@@ -1030,7 +1012,8 @@
 								ok=1;
 								D(bug("Dbuffering enabled!\n"));
 								this->hidden->dbuffer=1;
-								current->flags|=SDL_DOUBLEBUF;
+								if (current)
+									current->flags|=SDL_DOUBLEBUF;
 							}
 						}
 						else {
@@ -1039,16 +1022,23 @@
 						}
 					}
 
-					if(!ok)
-						flags&=~SDL_DOUBLEBUF;
+					if (!ok)
+						flags &= ~SDL_DOUBLEBUF;
 				}
 			}
 
-			if(GetCyberMapAttr(SDL_Display->RastPort.BitMap,CYBRMATTR_DEPTH)==bpp)
-				this->hidden->same_format=1;
+			D(bug("Screen bitmap: %ld (%ld), bpp %ld\n",
+					GetCyberMapAttr(SDL_Display->RastPort.BitMap,CYBRMATTR_BPPIX),
+					GetCyberMapAttr(SDL_Display->RastPort.BitMap,CYBRMATTR_DEPTH),                        
+					bpp));
+
+			if (bpp == GetCyberMapAttr(SDL_Display->RastPort.BitMap,CYBRMATTR_BPPIX) * 8) {
+				this->hidden->same_format = 1; // XXX check also pixfmt?
+				D(bug("SAME FORMAT bitmap -> Using RAW blits!\n"));
+			}
 		}
 
-		bpp=this->hidden->depth=GetCyberMapAttr(SDL_Display->RastPort.BitMap,CYBRMATTR_DEPTH);
+		bpp=this->hidden->depth = GetCyberMapAttr(SDL_Display->RastPort.BitMap,CYBRMATTR_DEPTH);
 		D(bug("Setting screen depth to: %ld\n",this->hidden->depth));
 
 		for ( i = 0; i < this->hidden->nvisuals; i++ )
@@ -1067,29 +1057,20 @@
 	saved_flags = current->flags;
 
 	if (SDL_Window && (saved_flags&SDL_OPENGL) == (flags&SDL_OPENGL)
-	    && bpp == current->format->BitsPerPixel && !needcreate) {
+	    && /* bpp == current->format->BitsPerPixel && */ !needcreate) {
 		if (CGX_ResizeWindow(this, current, width, height, flags) < 0) {
 			current = NULL;
 			goto done;
 		}
 	} else {
+		if (SDL_Window)
+			D(bug("bpp: %d (current %d)\n",bpp, current->format->BitsPerPixel));
 		if (CGX_CreateWindow(this,current,width,height,bpp,flags) < 0) {
 			current = NULL;
 			goto done;
 		}
 	}
 
-#if 0
-	/* Set up the new mode framebuffer */
-	if ( ((current->w != width) || (current->h != height)) ||
-             ((saved_flags&SDL_OPENGL) != (flags&SDL_OPENGL)) ) {
-		current->w = width;
-		current->h = height;
-		current->pitch = SDL_CalculatePitch(current);
-		CGX_ResizeImage(this, current, flags);
-	}
-#endif
-
 	current->flags |= (flags&SDL_RESIZABLE); // Resizable only if the user asked it
 
   done:
@@ -1135,74 +1116,6 @@
 	return(1);
 }
 
-static void SetSingleColor(Uint32 fmt, unsigned char r, unsigned char g, unsigned char b, unsigned char *c)
-{
-	switch(fmt)
-	{
-		case PIXFMT_BGR15:
-		case PIXFMT_RGB15PC:
-			{
-				Uint16 *t=(Uint16 *)c;
-				*t=(r>>3) | ((g>>3)<<5) | ((b>>3)<<10) ;
-			}
-			break;
-		case PIXFMT_RGB15:
-		case PIXFMT_BGR15PC:
-			{
-				Uint16 *t=(Uint16 *)c;
-				*t=(b>>3) | ((g>>3)<<5) | ((r>>3)<<10) ;
-			}
-			break;
-		case PIXFMT_BGR16PC:
-		case PIXFMT_RGB16:
-			{
-				Uint16 *t=(Uint16 *)c;
-				*t=(b>>3) | ((g>>2)<<5) | ((r>>3)<<11) ;
-			}
-			break;
-		case PIXFMT_BGR16:
-		case PIXFMT_RGB16PC:
-			{
-				Uint16 *t=(Uint16 *)c;
-				*t=(r>>3) | ((g>>2)<<5) | ((b>>3)<<11) ;
-			}
-			break;
-		case PIXFMT_RGB24:
-			c[0]=r;
-			c[1]=g;
-			c[2]=b;
-			c[3]=0;
-			break;
-		case PIXFMT_BGR24:
-			c[0]=b;
-			c[1]=g;
-			c[2]=r;
-			c[3]=0;
-			break;
-		case PIXFMT_ARGB32:
-			c[0]=0;
-			c[1]=r;
-			c[2]=g;
-			c[3]=b;
-			break;
-		case PIXFMT_BGRA32:
-			c[0]=b;
-			c[1]=g;
-			c[2]=r;
-			c[3]=0;
-			break;
-		case PIXFMT_RGBA32:
-			c[0]=r;
-			c[1]=g;
-			c[2]=b;
-			c[3]=0;
-			break;
-
-		default:
-			D(bug("Error, SetSingleColor with PIXFMT %ld!\n",fmt));
-	}
-}
-
 /* Update the current mouse state and position */
 static void CGX_UpdateMouse(_THIS)
 {
@@ -1246,12 +1159,10 @@
 		xcmap[0]=(ncolors<<16);
 		xcmap[0]+=firstcolor;
 
-//		D(bug("Setting %ld colors on an HWPALETTE screen\n",ncolors));
-
 		for ( i=0; i<ncolors; i++ ) {
-			xcmap[i*3+1] = colors[i+firstcolor].r<<24;
-			xcmap[i*3+2] = colors[i+firstcolor].g<<24;
-			xcmap[i*3+3] = colors[i+firstcolor].b<<24;
+			xcmap[i*3+1] = colors[i].r<<24;
+			xcmap[i*3+2] = colors[i].g<<24;
+			xcmap[i*3+3] = colors[i].b<<24;
 		}
 		xcmap[ncolors*3+1]=0;
 		LoadRGB32(&GFX_Display->ViewPort,xcmap);
@@ -1266,37 +1177,23 @@
 
 		if(this->hidden->depth==8)
 		{
-// In this case I have to unalloc and realloc the full palette
-			D(bug("Obtaining %ld colors on the screen\n",ncolors));
+//			D(bug("Obtaining %ld colors on the screen\n",ncolors));
 
-		/* Free existing allocated colors */
-			for ( pixel=0; pixel<this->screen->format->palette->ncolors; ++pixel ) {
+			for ( pixel=firstcolor; pixel<ncolors+firstcolor; pixel++ ) {
 				if(SDL_XPixels[pixel]>=0)
 					ReleasePen(GFX_Display->ViewPort.ColorMap,SDL_XPixels[pixel]);
 			}
 
 		/* Try to allocate all the colors */
-			for ( i=0; i<this->screen->format->palette->ncolors; ++i ) {
-				SDL_XPixels[i]=ObtainBestPenA(GFX_Display->ViewPort.ColorMap,colors[i].r<<24,colors[i].g<<24,colors[i].b<<24,NULL);
+			for ( i=0; i<ncolors; i++ ) {
+				SDL_XPixels[i+firstcolor]=ObtainBestPenA(GFX_Display->ViewPort.ColorMap,colors[i].r<<24,colors[i].g<<24,colors[i].b<<24,NULL);
 			}
 		}
 		else
 		{
-#ifndef USE_CGX_WRITELUTPIXEL
-			Uint32 fmt;
-			D(bug("Preparing a conversion pixel table...\n"));
-
-			fmt=GetCyberMapAttr(SDL_Display->RastPort.BitMap,CYBRMATTR_PIXFMT);
-
-			for(i=0;i<ncolors;i++)
-			{
-				SetSingleColor(fmt,colors[firstcolor+i].r,colors[firstcolor+i].g,colors[firstcolor+i].b,(unsigned char *)&SDL_XPixels[firstcolor+i]);
-			}
-#else
 //			D(bug("Executing XPixel(%lx) remapping: (from %ld, %ld colors) first: r%ld g%ld b%ld\n",SDL_XPixels,firstcolor,ncolors,colors[firstcolor].r,colors[firstcolor].g,colors[firstcolor].b));
 			for(i=0;i<ncolors;i++)
-				SDL_XPixels[i+firstcolor]=(colors[firstcolor+i].r<<16)+(colors[firstcolor+i].g<<8)+colors[firstcolor+i].b;
-#endif
+				SDL_XPixels[i+firstcolor]=(colors[i].r<<16)+(colors[i].g<<8)+colors[i].b;
 		}
 	}
 
diff -ruN SDL-1.2.11/src/video/cybergfx/SDL_cgxvideo.h SDL-1.2.11-aros/src/video/cybergfx/SDL_cgxvideo.h
--- SDL-1.2.11/src/video/cybergfx/SDL_cgxvideo.h	2006-05-01 10:02:46.000000000 +0200
+++ SDL-1.2.11-aros/src/video/cybergfx/SDL_cgxvideo.h	2009-11-07 18:05:25.000000000 +0100
@@ -30,7 +30,7 @@
 #include <graphics/scale.h>
 #include <graphics/gfx.h>
 #include <intuition/intuition.h>
-#if defined(__SASC) || defined(STORMC4_WOS)
+#if defined(__SASC) || defined(STORMC4_WOS) || defined(__AROS__)
 #include <proto/exec.h>
 #include <proto/cybergraphics.h>
 #include <proto/graphics.h>
@@ -43,6 +43,7 @@
 #include <inline/intuition.h>
 #include <inline/console.h>
 #endif
+#include <devices/rawkeycodes.h>
 
 #include "SDL_mouse.h"
 #include "../SDL_sysvideo.h"
