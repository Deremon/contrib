@DATABASE "xdme_cmds.guide"
@REMARK $Id$
@INDEX "index"
@NODE "MAIN" "XDME commands overview"
@TOC "MAIN"

This file contains a complete list of all commands of XDME sorted
alphabetically and by topic.

    @{" AREXX                    " LINK "arexx"}
    @{" Blockoperations          " LINK "block"}
    @{" Control structures       " LINK "program"}
    @{" General                  " LINK "general"}
    @{" IO Operations            " LINK "io"}
    @{" Keyboard                 " LINK "keys"}
    @{" Misc                     " LINK "misc"}
    @{" Move in the text         " LINK "movement"}
    @{" Preferences and Settings " LINK "prefs"}
    @{" Requester                " LINK "requester"}
    @{" Search and Replace       " LINK "searchreplace"}
    @{" Stack                    " LINK "stack"}
    @{" Text Editing             " LINK "textedit"}
    @{" Text formatting          " LINK "format"}
    @{" Variable                 " LINK "var"}
    @{" Windows                  " LINK "win"}

@ENDNODE "MAIN"

@NODE "arexx" "AREXX"
@TOC "MAIN"

@ENDNODE "arexx"

@NODE "block" "Blockoperations"
@TOC "MAIN"

@{B}POPMARK@{UB}             pop the block stack and highlight the popped block
@{B}PURGEMARK@{UB}           clear the mark stack
@{B}PUSHMARK@{UB}            push the currently marked block onto a stack and
                    unhighlight the block
@{B}SWAPMARK@{UB}            PUSHMARK, swap top two marks on stack, POPMARK
@ENDNODE "block"

@NODE "program" "Control structures"
@TOC "MAIN"

@{B}ABORT@{UB}               stop macro execution
@{B}BREAK@{UB}               leave current loop (WHILE, REPEAT)
@{B}CONTINUE@{UB}            start loop over (WHILE, REPEAT)
@{B}EVAL com@{UB}            split long commandsequences to keep MAXIA small
@{" FORCE " LINK "desc2"} @{B}flag command@{UB} set special conditions for executing @{B}command@{UB}
@{B}UNABORT@{UB}             clear abort flag (only in an AREXX script)
@ENDNODE "program"

@NODE "general" "General"
@TOC "MAIN"

@{B}(text)@{UB}         enter @{B}text@{UB} as if typed
@{B}key@{UB}		execute a keymap as a macro (example @{B}-return@{UB})
@{B}header-item@{UB}	execute a menu item as a macro (example: @{B}Project-Save@{UB})
	       (case independent)
@ENDNODE "general"

@NODE "io" "IO Operations"
@TOC "MAIN"

    XDME will always save the text at the place where it came from, expect
    you have used the @{B}CD@{UB} command to change the current directory.

@{B}KEYLOAD filename@{UB}    replace the current keymap with the contents of @{B}filename@{UB}
@{B}KEYSAVE filename@{UB}    save the current keymap into @{B}filename@{UB}
@{B}MACROLOAD filename@{UB}  load macros from a file
@{B}MACROSAVE filename@{UB}  save the current macros into a file with a special format
@{B}MENULOAD filename@{UB}   replace the current menustrip with the one from the file
@{B}MENUSAVE filename@{UB}   write the current menustrip in a file
@ENDNODE "io"

@NODE "keys" "Keyboard"
@TOC "MAIN"

@{B}KEYLOAD filename@{UB}    replace the current keymap with the contents of @{B}filename@{UB}
@{B}KEYSAVE filename@{UB}    save the current keymap into @{B}filename@{UB}
@{" MAP " LINK "desc0"} @{B}key map@{UB}      map a key to a keymap
@{B}NEWKEYTABLE name@{UB}    use a keytable or create a new one
@{B}REMKEYTABLE@{UB}         delete the current keytable, if it is not the only one
@{" UNMAP " LINK "desc0"} @{B}key@{UB}        unmap a key
@{B}USEKEYTABLE name@{UB}    search for a certain keytable and use it as the current
                    one
@ENDNODE "keys"

@NODE "misc" "Misc"
@TOC "MAIN"

@ENDNODE "misc"

@NODE "movement" "Move in the text"
@TOC "MAIN"

@ENDNODE "movement"

@NODE "prefs" "Preferences and Settings"
@TOC "MAIN"

    @{B}what@{UB} is one of on, off or toggle to switch the option on,
    off or to change its state.

@{" MAP " LINK "desc0"} @{B}key map@{UB}      map a key to a keymap
@{" UNMAP " LINK "desc0"} @{B}key@{UB}        unmap a key
@ENDNODE "prefs"

@NODE "requester" "Requester"
@TOC "MAIN"

@ENDNODE "requester"

@NODE "searchreplace" "Search and Replace"
@TOC "MAIN"

@ENDNODE "searchreplace"

@NODE "stack" "Stack"
@TOC "MAIN"

@{B}PICKVAR varname@{UB}     get the latest to variable-stack pushed contents of the
                    variable varname back without freeing the stack-entry
@{B}POPMARK@{UB}             pop the block stack and highlight the popped block
@{B}POPVAR varname@{UB}      get the latest to variable-stack pushed contents of the
                    variable varname back and free the stack-entry
@{B}PURGEMARK@{UB}           clear the mark stack
@{B}PURGEVAR varname@{UB}    remove all entries with the name varname from varstack
@{B}PUSHMARK@{UB}            push the currently marked block onto a stack and
                    unhighlight the block
@{B}PUSHVAR varname@{UB}     push the contents of the variable varname onto
                    variable-stack
@{B}SWAPMARK@{UB}            PUSHMARK, swap top two marks on stack, POPMARK
@{B}SWAPVAR varname@{UB}     swap the contents of the variable varname and of its first
                    occurancy in variable-stack
@ENDNODE "stack"

@NODE "textedit" "Text Editing"
@TOC "MAIN"

@{B}INSERT text@{UB}         insert some text at the current position
@{B}OVERWRITE text@{UB}      overwrite the text at the current position with @{B}text@{UB}
@{B}PRINTF format parameters@{UB} create a string with @{B}format@{UB} and its (up to 8)
                    @{B}parameters@{UB} and write it into the current text
@{B}READTEMPLATE file@{UB}   insert @{B}file@{UB} and replace variables
@ENDNODE "textedit"

@NODE "format" "Text formatting"
@TOC "MAIN"

@{B}PRINTF format parameters@{UB} create a string with @{B}format@{UB} and its (up to 8)
                    @{B}parameters@{UB} and write it into the current text
@ENDNODE "format"

@NODE "var" "Variable"
@TOC "MAIN"

@{B}FLAG name what@{UB}      change flag @{B}name@{UB} by @{B}what@{UB}
@{B}PICKVAR varname@{UB}     get the latest to variable-stack pushed contents of the
                    variable varname back without freeing the stack-entry
@{B}POPVAR varname@{UB}      get the latest to variable-stack pushed contents of the
                    variable varname back and free the stack-entry
@{B}PURGEVAR varname@{UB}    remove all entries with the name varname from varstack
@{B}PUSHVAR varname@{UB}     push the contents of the variable varname onto
                    variable-stack
@{B}RESETTOGGLE n@{UB}       clear toggle array entry @{B}n@{UB} = 0..255
@{B}SET var str@{UB}         create/modify an internal variable (access without $)
@{B}SETENV var str@{UB}      create/modify an enviroment variable (1.3 ENV:)
@{B}SETMACROVAR name val@{UB} definition of a macro's local variable inside a macro
@{B}SETTOGGLE n@{UB}         set toggle array entry @{B}n@{UB} = 0..255
@{B}SETTVAR var str@{UB}     create/modify text-local variable (access without $)
@{B}SMV name val@{UB}        short for @{B}SETMACROVAR name val@{UB}
@{B}SWAPVAR varname@{UB}     swap the contents of the variable varname and of its first
                    occurancy in variable-stack
@{B}TOGGLE n@{UB}            flip toggle array entry @{B}n@{UB} = 0..255
@{B}UNSET var@{UB}           delete an internal variable
@{B}UNSETENV var@{UB}        delete an enviroment variable
@{B}UNSETMACROVAR name@{UB}  deletion of a macro's local variable
@{B}UNSETTVAR var@{UB}       delete a text-local variable
@ENDNODE "var"

@NODE "win" "Windows"
@TOC "MAIN"

@ENDNODE "win"

@NODE "desc0" "MAP,UNMAP"
@TOC "MAIN"

@{B}MAP key map@{UB}
@{B}UNMAP key@{UB}

with these commands you can modify the keytable.

@{B}MAP@{UB} adds or modifies an existing key-entry to the keytable
@{B}UNMAP@{UB} deletes an existing key-entry

key consists of a set of qualifiers, a "-" and one code (both case sensitive)

The qualifiers are:

	s == any shift (caps-lock with alpha-keys)
	c == control
	a == any alt
	A == any amiga
	L == left mouse button
	M == middle mouse button
	R == right mouse button
	u == key-up ( release of a key )
	x == extended qualifier x
	y == extended qualifier y
	z == extended qualifier z
	r == repeat

the code-specification is one out of:

    main keyboard:
	[single lowercase character] == the key on you main keyboard - that shows it
	[single uppercase alpha]     == the key on .... but that means a set s-qualifier

    numeric keypad:
	@{B}nk0@{UB} .. @{B}nk9@{UB}		  == numerik keypad 0..9
	@{B}nk+@{UB}, @{B}nk-@{UB}, @{B}nk*@{UB}, @{B}nk/@{UB}, @{B}nk.@{UB} == numerik keypad +,-,*,/,.

	There are two more keys on your numeric keypad. With
	american or british mapping, they are used as @{B}nk(@{UB} and @{B}nk)@{UB}. With most
	european mappings they are used as @{B}nk[@{UB} and @{B}nk]@{UB}. With canadian
	mapping they are used as @{B}nk\@@{UB} and @{B}nk°@{UB} If there is a standart
	mapping, that does map these keys in another way, they are NOT
	supported yet. (please mail)

	other special keys:
	  @{B}f1 .. f10@{UB}	  == Function keys
	  @{B}hel@{UB}		  == help-key
	  @{B}esc@{UB}		  == escape
	  @{B}del@{UB}		  == delete
	  @{B}bac@{UB}, @{B}bs@{UB}	   == backspace ( <- )
	  @{B}tab@{UB}		  == tabulator
	  @{B}ent@{UB}		  == enter
	  @{B}spc@{UB}, @{B}spa@{UB}	   == spacebar
	  @{B}up@{UB}, @{B}dow@{UB}, @{B}rig@{UB},
	  @{B}lef@{UB}		  == cursor keys

	  @{B}lmb@{UB}, @{B}mmb@{UB}, @{B}rmb@{UB}  == mouse buttons
	  @{B}mmo@{UB}		  == mouse movement with a mousebutton pressed
	  @{B}?m2@{UB}, @{B}?m3@{UB}, @{B}?m4@{UB}  == (? in [lmr]) double/triple/qraduple clicks of a
			    certain mouse button (times out!)

Note that as mousebuttons can act for qualifying as well as for specifying,
the specifying mousebutton must also be qualifying e.g @{B}L-rmb@{UB} doesn't work,
but @{B}LR-rmb@{UB} does.

Note that certain keys may be used as dead-keys; keys that are deading when
pressed without qualifiers are not accessible with this keyboard-interface.
e.g. on german keyboards there is a key @{B}"'"@{UB} next to @{B}"\\"@{UB} which cannot be
accessed. On the other hand, if a key is deading on a qualified level, but
not when pressed without qualifiers, you can remap it e.g on german
keyboards @{B}alt-f@{UB} is deading, but @{B}-f@{UB} not, so you can access @{B}a-f@{UB}; and if you
map @{B}a-f@{UB} to any function, it looses its deading function for [X]DME

    EXAMPLE:  @{B}<alt-f> <a>@{UB} creates something like @{B}"á"@{UB}
	      after a @{B}"MAP a-f (NULL)"@{UB} the same key-sequence
	      creates a normal @{B}"a"@{UB}

Keys with the x, y or z qualifiers set can't be accessed immediately. First
you must set the extended qualifiers (see QUALIFIER command), then you may
press the remaining qualifiers and keys. These qualifiers were introduced
to allow something like the @{B}CTL-X@{UB} prefix of (Micro)Emacs.

    ATTENTION !

	We check only the first three characters of the code-specification
	so e.g. @{B}-space@{UB} is recognized as @{B}-spa@{UB}. some people call this a
	feature, but in fact it is a BUG, as this method makes problems
	with rexx-commands which start with these 3 first characters. XDME
	will ignore such commands and do whatever this key is supposed to
	do.

@ENDNODE "desc0"

@NODE "desc1" "MENUADD"
@TOC "MAIN"

@{B}MENUADD hdr item cmd@{UB}

    SUBnames	   are splitted at ^S,
    AMIGAshortcuts are splitted at ^A,
    CHECKitems	   are leaded	by ^C (at subs the last/sub name),
    BARitems	   are called	   ^B (at subs the last/sub name)

EXAMPLES:

    @{B}menuadd demo demo^Stest^AW@{UB} 	Add "demo/demo/test" with Hotkey
    @{B}menuadd demo demo^S^B@{UB}		Add subitembar
    @{B}menuadd demo demo^S^Ctest2@{UB} 	Add subitem "test2" with checkmark
    @{B}menuadd demo ^B@{UB}			Add itembar

@ENDNODE "desc1"

@NODE "desc2" "FORCE"
@TOC "MAIN"

@{B}FORCE flag command@{UB}

To execute a command under special conditions. @{B}flag@{UB} is

      T 	    don't change title
      S 	    quiet (no Screen updating)
      F 	    unable to fail
      R 	    no Requestors
      D 	    enable debugging mode
     `'             simple eval

@ENDNODE "desc2"

@NODE "desc3" "MENUON,MENUOFF,MENUADD"
@TOC "MAIN"

@{B}MENUADD hdr item cmd@{UB}
@{B}MENUOFF @{UB}
@{B}MENUON @{UB}

This command will enable/disable menus.  Users who have a whole bunch of
MENUADD commands in their @{B}.EDRC@{UB} should note that disabling menus at the
beginning will speed up the MENUADD commands. Then reenable menus at the
end.  These calls are stackable in that if you call MENUOFF, say, twice, it
will take two MENUON@ commands to restore menus. The reverse is not true.

@ENDNODE "desc3"

@NODE "desc4" "CTAGS"
@TOC "MAIN"


(1.30B and beyond) Compatible with Aztec's CTAGS program. This command
searches for the subroutine name under the cursor in the associated tags
file ("tags" in the directory holding the file currently being edited).
Also, the file "tags" in directories specified by the special XDME path
(see ADDPATH and REMPATH) will be searched.

If the tag is found, it loads the file the subroutine resides in if
neccesary, then WindowToFront()'s the window, ActivateWindow()s it, and
GOTO's the line where the subroutine starts.  The search within the source
file is anchored to the left column.  If the file is already loaded, it is
not reloaded.

This enables a programmer to quickly trace subroutines over an arbitrary
number of files.

The tags file contains one or more lines of the following format:

@{B}subroutine-name file-name /^search-pattern@{UB}
			    (that's a slash and a carrot, then the pattern)

    -- EXAMPLE of 'TAGS' file:
    @{B}setpen cmd1.c /^setpen(@{UB}
    @{B}do_up cmd1.c /^do_up(@{UB}
    --

SPECIAL NOTE:  CTAGS will work even if you are not in the directory
containing the file.  You can thus place a tags file in the directory
containing the files it references, and the filenames WITHIN the tags file
need not be a full path.

@ENDNODE "desc4"

@NODE "desc5" "REF"
@TOC "MAIN"


(1.28d and beyond).  This is a very powerful new command that allows you to
bring up a reference to a keyword with a single keystroke.  This is useful
for programmers who have on-line documentation or fully commented include
files. XDME opens a window just big enough to fit the reference.

NOTE:  The new CTAGS command may be more suited to your application.

The reference keyword is the alpha-numeric string currently under the
cursor.  REF will search the file @{B}DME.REFS@{UB} in the directories listed by
the special XDME path (see ADDPATH and REMPATH).  The file must be built by
the user and each line has the following format:

    (@{B}keyword@{UB}) (@{B}nolines@{UB}/@{B}endstring@{UB}) (@{B}file@{UB}) (@{B}searchstr@{UB}/@{B}@@seekpos@{UB})

Surrounding the keywords with `' or () is optional if the keyword does not
contain spaces.

    @{B}keyword@{UB}	     keyword under cursor
    @{B}nolines@{UB}/@{B}ends@{UB}    either a number (the number of lines in the reference)
		    or a string denoting the end of the reference when found.
    @{B}file@{UB}	     the file containing the reference material
    @{B}searchstr@{UB}/@{B}@@@{UB}    search string in file that indicates the beginning of
		    the reference, or two at's (@{B}@@@{UB}) and the seek position
		    in decimal (like @{B}@@2343@{UB}).  The latter method is used
		    mainly for reference- generator programs.

Upon finding a successful keyword match the specified file is openned and
the seach string searched for.	If a seek position was specified no search
is made and a seek is made to the beginning of the reference.  If found,
the indicated number of lines (if a number is specified for <nolines/ends>)
or until a match with the endstring (if a string was specified) will be
placed in a temporary file and a new XDME window brought up. The temporary
file is then deleted.

When looking for matches, the compare is anchored at the beginning of each
line in the file.  Thus, any spaces in front of the string in the file must
be duplicated.

T: must be assigned to a temporary directory, usually RAM: See the included
example DME.REFS file.	The most common things referenced are the autodocs
and commented include files.

Some modification of the included @{B}DME.REFS@{UB} files may be required due to
differences in include file and autodoc format.

@ENDNODE "desc5"

@NODE "desc6" "SCANF"
@TOC "MAIN"


This is equivalent to the C scanf() function with the restriction that only
one conversion is allowed, that conversion being a string.  Thus:

    @{B}scanf %s@{UB}	     will place the string under the cursor in the variable
		    @{B}$scanf@{UB}

    @{B}scanf %4s@{UB}	     The first four chars of the string.

    @{B}scanf %[0123456789]@{UB}
		    will scan the string while it contains
		    specified chars (e.g. scan a number)

    @{B}scanf %[~,]@{UB}     will scan the string until it finds a @{B}','@{UB}.

Moreover SCANF now allows to use some more usefull arguments:

    @{B}w@{UB}	 - one word
    @{B}l@{UB}	 - the WHOLE line
    @{B}b@{UB}	 - all that matches isalnum()
    @{B}c@{UB}	 - single character
    @{B}t@{UB}	 - text in one line
    @{B}a@{UB}	 - all that matches isalpha()
    @{B}r@{UB}	 - c-style comment

If you precede one of these with a @{B}'+'@{UB} you will also get everything to the
left else you get all that is to the right. Example:

    @{B}dummy1[line] =@{UB} ...
	^

    @{B}w@{UB}:  my1[line]
    @{B}+w@{UB}: dummy1[line]
    @{B}a@{UB}:  my
    @{B}+a@{UB}: dummy
    @{B}b@{UB}:  my1
    @{B}+b@{UB}: dummy1
    @{B}c@{UB}:  m
    @{B}+c@{UB}: m

The variable @{B}$scanf@{UB} may be used as an argument in any command.  Example:
(@{B}insfile $scanf@{UB}).

NOTE:  If using @{B}$scanf@{UB} in a macro, you probably want to precede it with a \\
to prevent it from being evaluated at macro-creation time.

@ENDNODE "desc6"

@NODE "desc7" "REPEAT"
@TOC "MAIN"


Repeat @{B}arg@{UB} @{B}n@{UB} times.  Apart from being a number, @{B}n@{UB} can also be one of:

    @{B}line@{UB}    Current line # (lines begin at 1)
    @{B}lbot@{UB}    #lines to the bottom, including current line
    @{B}cleft@{UB}   column # (cols begin at 0)
    @{B}cright@{UB}  #chars to eol, including current char under cursor
    @{B}tr@{UB}      #char positions to next tab
    @{B}tl@{UB}      #char positions to next back tab

Certain commands can abort a REPEAT loop. Specifically, any FIND[R],
NEXT[R], or PREV[R] in which the search string is NOT found will abort a
REPEAT. Most operations which can go out of bounds, such as UP, LEFT,
RIGHT, DOWN, also abort a repeat.

Specifying @{B}-1@{UB} as @{B}n@{UB} causes REPEAT to go on forever (well, actually,
@{B}0xFFFFFFFF@{UB} times) or until an abort.

REPEAT may also be abreviated. Simply type

    @{B}15 left@{UB}

This will move the cursor 15 times @{B}left@{UB}. In this construction you must
specify a number as repeat-count.

@ENDNODE "desc7"

@NODE "desc8" "IF,WHILE,IFELSE"
@TOC "MAIN"


If the specified condition is true, execute the argument.  For WHILE, the
argument is executed until the condition is false (be careful!), but you
may abort while with CTRL-c (be fast !).

the optional '!' inverts the logic.

    Conditions:


    @{B}#@{UB}	     if toggle entry # is SET.	there are 256 toggles (0..255)
    @{B}t@{UB}	     if On line 1
    @{B}b@{UB}	     if On last line
    @{B}l@{UB}	     if At column 0
    @{B}r@{UB}	     if At end of line (spaces below and beyond)
    @{B}m@{UB}	     if Text has been modified
    @{B}i@{UB}	     if in insert mode
    @{B}x[<=>]#@{UB} if column position (starts at 1) is (any OR combo of
	    <, =, or >) than some number.  Example:   @{B}x<=20@{UB}
    @{B}y[<=>]#@{UB} if Line number (starts at 1) is (same as for x)
    @{B}cl@{UB}      character under cursor is lower case alpha
    @{B}cu@{UB}      character under cursor is upper case alpha
    @{B}ca@{UB}      character under cursor is alpha-numeric
    @{B}cn@{UB}      character under cursor is numeric
    @{B}cb@{UB}      cursor within a block
    @{B}c[<=>]#@{UB} character under cursor is ascii code # (# in decimal)
	    optional conditionals as in '@{B}x@{UB}' and '@{B}y@{UB}'.
		# can also be a "string":

		@{B}if c="hwllo" `right tlate "e"'@{UB}

	    replaces "@{B}hwllo@{UB}" by "@{B}hello@{UB}". The condition is true, if the
	    cursor is on the first char of the string and the string
	    follows behind:

		@{B}This is a test.@{UB}
		     ^

		@{B}ifelse c="is" `title c=is' `title c<>is'@{UB}:    @{B}c=is@{UB}
		@{B}ifelse c="test" `title TRUE' `title FALSE'@{UB}:  @{B}FALSE@{UB}

	    # can be a group of chars:

		@{B}while c=[a-zA-Z0-9]@{UB} ...

	    is the same as

		@{B}while ca@{UB} ...

	    Beware of spaces in strings and groups: if there are any, you
	    MUST NOT forget to put the condition in XDME's parentheses.

@ENDNODE "desc8"

@NODE "desc9" "INDENT"
@TOC "MAIN"


The INDENT-command allows to indent and outdent text. It is intelligent in
a way that you will NEVER lose any text with it. If the in/outdent would
push characters over the limit (left or right), the line is left and INDENT
continues with the next line.

    what:   @{B}.@{UB}	     Current line
	    @{B}n@{UB}	     line n
	    @{B}$n@{UB}      line which is marked by PING n
	    @{B}t@{UB}	     whole text
	    @{B}b@{UB}	     whole @{"block" LINK "block"}
	    @{B}bs@{UB}      block start
	    @{B}be@{UB}      block end
	    @{B}_@{UB}	     last line

	You may create ranges with "@{B}what,what@{UB}". (This is obviously useless
	with "@{B}t@{UB}" and "@{B}b@{UB}").

    how:    @{B}-@{UB}	     If there is a minus, text is outdented instead of
		    indented
	    @{B}.@{UB}	     Align to multiple of indent-amount instead of just
		    inserting some spaces at the beginning
	    @{B}n@{UB}	     Set indent-amount to n
	    @{B}t@{UB}	     Set indent-amount to tabsize
	    @{B}c@{UB}	     Insert not at the beginning but at the current column.

    Examples:

	@{B}indent . .ct@{UB}	 Acts like tab. Text under cursor and beyond is
			aligned to next tabstop.
	@{B}indent b .t@{UB}	 Indent the current block. NOTE: ALL lines are
			tabstop-aligned ! This may destroy some of
			your formating.
	@{B}indent b -.t@{UB}	 dito but the block is outdented.

@ENDNODE "desc9"

@NODE "desc10" "TLATE"
@TOC "MAIN"


translate character under cursor. @{B}how@{UB} can be one of the following:

    @{B}number@{UB}	 Replace character by the character with the code number.
		(i.e. @{B}65=A@{UB}). Number can be a decimal-, octal- or hexnumber.

    @{B}[+-]number@{UB}  As above, but the actual character is used as offset:
		@{B}`tlate +1'@{UB} makes a @{B}'B'@{UB} from an @{B}'A'@{UB}, @{B}`tlate -1'@{UB} does the
		reverse. The resulting char-code is truncated to 8bit.

    @{B}"x"@{UB}         Replace actual character by @{B}'x'@{UB}.

    @{B}[Uu]@{UB}	 Make character uppercase.

    @{B}[Ll]@{UB}	 Make character lowercase.

@ENDNODE "desc10"

@NODE "desc11" "SETGEOMETRY"
@TOC "MAIN"


Set @{B}x/y@{UB} position and @{B}width/height@{UB} of XDME's window. The width and height
are ignored in iconified state. If you use negative values, the
positions/sizes are relative the current screen-size (@{B}0 0 -1 -1@{UB} will open a
full-sized window !). If a size is null, it's left unchanged (move window
only).

@ENDNODE "desc11"

@NODE "desc12" "GOTO"
@TOC "MAIN"


Goto to a position in the text. dest is one of

    @{B}BLOCK/START@{UB}     Beginning of @{"block" LINK "block"} (if there's one)
    @{B}END@{UB}	     Last line of block (dito)
    @{B}n@{UB}		     to line @{B}n@{UB}
    @{B}+n@{UB} 	     @{B}n@{UB} lines down
    @{B}-n@{UB} 	     @{B}n@{UB} lines up

@ENDNODE "desc12"

@NODE "desc13" "REPLACE"
@TOC "MAIN"


replaces the next @{B}strlen(findstr)@{UB} chars with @{B}repstr@{UB} (ie. if deletes as many
chars as are in @{B}findstr@{UB} and replaces them by the replace-string). Useful in
a mapping to find the text and another to actually replace the text:

    @{B}map f1 `next'@{UB}
    @{B}map f2 `replace next'@{UB}

@{B}f1@{UB} searches for the text, @{B}f2@{UB} replaces it and looks for the next occurence.

@ENDNODE "desc13"

@NODE "desc14" "PROJECTINFO"
@TOC "MAIN"


Gives some information about the current project.

    @{B}result_string="%s %d %d %d %d %d %d",
		name, LeftEdge, TopEdge, Width,
		Height, IWinX, IWinY@{UB}

i.e. Name of current window, it's dimensions and position when iconified

@ENDNODE "desc14"

@NODE "desc15" "SELECT"
@TOC "MAIN"


make a window the current one. @{B}what@{UB}:

    @{B}FIRST, LAST, NEXT, PREVIOUS@{UB}     obvious, eh ?
    @{B}WINDOW=name@{UB}		     Make window @{B}name@{UB} the current one
    @{B}SAVE@{UB}			     Remember current window
    @{B}LOAD@{UB}			     restore current window

You can @{B}SAVE@{UB} the current window, select another (or more) and @{B}LOAD@{UB} the
current window again. This gurantees uninterupted work for the user and is
STRONGLY recommended.

@ENDNODE "desc15"

@NODE "desc16" "PICK,PUSH,POP"
@TOC "MAIN"


Push/pop an item on/from the stack. @{B}Items@{UB} are

    @{B}POS@{UB}	 - actual cursor position (like @{B}PING@{UB})
    @{B}MODIFIED@{UB}	 - modified flag
    @{B}ICONMODE@{UB}	 - iconify-state
    @{B}TABSTOP@{UB}	 - tab-size
    @{B}SAVETABS@{UB}	 - Should I convert spaces to tabs ?
    @{B}MARGIN@{UB}	 - right margin
    @{B}INSERTMODE@{UB}  - obvious :-)
    @{B}IGNORECASE@{UB}  - for search
    @{B}WORDWRAP@{UB}	 - word-wrapping on/off
    @{B}WWCOL@{UB}	 - col. of wordwrap
    @{B}WINDOW@{UB}	 - position and size of window
    @{B}ICON@{UB}	 - position of icon
    @{B}PENS@{UB}	 - all pens
    @{B}BLOCK@{UB}	 - like @{B}PUSH@{UB}-/POPMARK
    @{B}ED@{UB} 	 - actual window. Like SELECT SAVE, but can be nested
    @{B}AUTO@{UB}	 - POP only ! This automatically put the topmost thing from
		stack to its original place.
    @{B}DISCARD@{UB}	 - POP only ! Discards the topmost item from the stack.

@ENDNODE "desc16"

@NODE "desc17" "OPENWINDOW"
@TOC "MAIN"


open new window using specified geometry.  Geometry is specified as:
@{B}+/-leftedge+/-topedge+/-width+/-height@{UB}, where negative numbers denote
values relative to the width or height of the screen.  For example, the
following opens a nearly full-screen window leaving 10 pixels above, below,
to the left, and to the right:

    @{B}openwindow +10+10-10-10@{UB}

The following opens a window in the upper right hand corner of width 320
and height 100.

    @{B}openwindow  -320+0+320+100@{UB}
    @{B}openwindow  -320+0-0+100@{UB}	     (same thing)
    @{B}openwindow  -320-100-0-0@{UB}	     (lower right hand corner)

@ENDNODE "desc17"

@NODE "desc18" "JUSTIFY,UNJUSTIFY"
@TOC "MAIN"


These commands format a single line of text. @{B}UNJUSTIFY@{UB} removes all
formatting (ie. all obsolete spaces). @{B}JUSTIFY@{UB} inserts spaces. The following
formats are available:

	@{B}full@{UB}	     insert spaces between words until the last character
		    in the line is at @{B}MARGIN@{UB}.
	@{B}left@{UB}	     removes all leading spaces
	@{B}right@{UB}	     inserts spaces at the beginning of the line until the
		    last character in the line is at @{B}MARGIN@{UB}.
	@{B}center@{UB}      center line between left border and @{B}MARGIN@{UB}.

If you want to reformat a whole paragraph, mark it as a block and
use

	@{B}GOTO BLOCK@{UB}	    goto beginning of paragraph
	@{B}WHILE CB (@{UB}         while in block ...
	    @{B}JUSTIFY LEFT@{UB}	remove leading spaces
	    @{B}UNJUSTIFY@{UB}		remove all interword spaces
	    @{B}DOWN )@{UB}		next line
	@{B}GOTO BLOCK@{UB}	    goto beginning of paragraph again
	@{B}REFORMAT@{UB}	    collect words anew
	@{B}WHILE CB (@{UB}         while in block
	    @{B}JUSTIFY @{I}how@{UI}@{UB}	 justify the line
	    @{B}DOWN )@{UB}		next line
@ENDNODE "desc18"

@NODE "index" "Index"
@TOC "MAIN"

@{B}ABORT@{UB}               stop macro execution
@{B}ADD var val@{UB}         add @{B}val@{UB} to @{B}var@{UB}
@{B}BREAK@{UB}               leave current loop (WHILE, REPEAT)
@{B}CONTINUE@{UB}            start loop over (WHILE, REPEAT)
@{B}DEC var@{UB}             sub 1 from @{B}var@{UB}
@{B}DIV var val@{UB}         divide @{B}var@{UB} by @{B}val@{UB}
@{B}EVAL com@{UB}            split long commandsequences to keep MAXIA small
@{B}FLAG name what@{UB}      change flag @{B}name@{UB} by @{B}what@{UB}
@{" FORCE " LINK "desc2"} @{B}flag command@{UB} set special conditions for executing @{B}command@{UB}
@{B}INC var@{UB}             add 1 to @{B}var@{UB}
@{B}INSERT text@{UB}         insert some text at the current position
@{B}KEYLOAD filename@{UB}    replace the current keymap with the contents of @{B}filename@{UB}
@{B}KEYSAVE filename@{UB}    save the current keymap into @{B}filename@{UB}
@{B}MACROLOAD filename@{UB}  load macros from a file
@{B}MACROSAVE filename@{UB}  save the current macros into a file with a special format
@{" MAP " LINK "desc0"} @{B}key map@{UB}      map a key to a keymap
@{" MENUADD " LINK "desc1"} @{B}hdr item cmd@{UB} add menu item
@{B}MENUCHKITEM menuname itemname variablename@{UB} write the current status (0 or 1)
                    of an checkmarks in a variable
@{B}MENUCLEAR@{UB}           delete entire menu
@{B}MENUDEL hdr item@{UB}    delete menu item
@{B}MENUDELHDR hdr@{UB}      delete menu header
@{B}MENULOAD filename@{UB}   replace the current menustrip with the one from the file
@{" MENUOFF " LINK "desc3"}          disable menus (multiple calls are stacked)
@{" MENUON " LINK "desc3"}           This command will enable menus.
@{B}MENUSAVE filename@{UB}   write the current menustrip in a file
@{B}MENUSETITEM menuname itemname status@{UB} set the status of a menu-item with
                    checkmarks
@{B}MOD var val@{UB}         module of @{B}var@{UB} by @{B}val@{UB}
@{B}MUL var val@{UB}         multiply @{B}var@{UB} by @{B}val@{UB}
@{B}NEG var@{UB}             negate the value of @{B}var@{UB}
@{B}NEWKEYTABLE name@{UB}    use a keytable or create a new one
@{B}NEWMENUSTRIP name@{UB}   use a menustrip or create a new one
@{B}NOT var@{UB}             logical not for @{B}var@{UB}
@{B}OVERWRITE text@{UB}      overwrite the text at the current position with @{B}text@{UB}
@{B}PICKVAR varname@{UB}     get the latest to variable-stack pushed contents of the
                    variable varname back without freeing the stack-entry
@{B}POPMARK@{UB}             pop the block stack and highlight the popped block
@{B}POPVAR varname@{UB}      get the latest to variable-stack pushed contents of the
                    variable varname back and free the stack-entry
@{B}PRINTF format parameters@{UB} create a string with @{B}format@{UB} and its (up to 8)
                    @{B}parameters@{UB} and write it into the current text
@{B}PURGEMARK@{UB}           clear the mark stack
@{B}PURGEVAR varname@{UB}    remove all entries with the name varname from varstack
@{B}PUSHMARK@{UB}            push the currently marked block onto a stack and
                    unhighlight the block
@{B}PUSHVAR varname@{UB}     push the contents of the variable varname onto
                    variable-stack
@{B}READTEMPLATE file@{UB}   insert @{B}file@{UB} and replace variables
@{B}RECEND@{UB}              end macro recording
@{B}RECPLAY@{UB}             use previously recorded macro
@{B}RECSAVE file@{UB}        save recorded macro to a file. Execute with @{B}SOURCE@{UB}
@{B}RECSTART@{UB}            start macro recording
@{B}REMKEYTABLE@{UB}         delete the current keytable, if it is not the only one
@{B}REMMENUSTRIP@{UB}        delete the current menustrip, if it is not the only one
@{B}RESETTOGGLE n@{UB}       clear toggle array entry @{B}n@{UB} = 0..255
@{B}RET@{UB}                 terminate macro
@{B}SET var str@{UB}         create/modify an internal variable (access without $)
@{B}SETENV var str@{UB}      create/modify an enviroment variable (1.3 ENV:)
@{B}SETMACRO name numargs body@{UB} define the macro @{B}name@{UB} with @{B}numargs@{UB} arguments.
@{B}SETMACROVAR name val@{UB} definition of a macro's local variable inside a macro
@{B}SETTOGGLE n@{UB}         set toggle array entry @{B}n@{UB} = 0..255
@{B}SETTVAR var str@{UB}     create/modify text-local variable (access without $)
@{B}SIMPTR x y@{UB}          simulate a mouse-movement. @{B}x@{UB} and @{B}y@{UB} are in pixels.
@{B}SMV name val@{UB}        short for @{B}SETMACROVAR name val@{UB}
@{B}SUB var val@{UB}         sub @{B}val@{UB} from @{B}var@{UB}
@{B}SWAPMARK@{UB}            PUSHMARK, swap top two marks on stack, POPMARK
@{B}SWAPVAR varname@{UB}     swap the contents of the variable varname and of its first
                    occurancy in variable-stack
@{B}TOGGLE n@{UB}            flip toggle array entry @{B}n@{UB} = 0..255
@{B}UNABORT@{UB}             clear abort flag (only in an AREXX script)
@{" UNMAP " LINK "desc0"} @{B}key@{UB}        unmap a key
@{B}UNSET var@{UB}           delete an internal variable
@{B}UNSETENV var@{UB}        delete an enviroment variable
@{B}UNSETMACRO name@{UB}     delete macro @{B}name@{UB}
@{B}UNSETMACROVAR name@{UB}  deletion of a macro's local variable
@{B}UNSETTVAR var@{UB}       delete a text-local variable
@{B}USEKEYTABLE name@{UB}    search for a certain keytable and use it as the current
                    one
@{B}USEMENUSTRIP name@{UB}   switch to menustrip @{B}name@{UB}
@ENDNODE "index"

