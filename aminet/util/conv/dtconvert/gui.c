/*
 *  Source machine generated by GadToolsBox V2.0b
 *  which is (c) Copyright 1991-1993 Jaba Development
 *
 *  GUI Designed by : Roland Mainz, GISBURN@W-Specht.rhein-ruhr.de
 */

#include "DTConvert.h"
#include "gui.h"

struct Screen         *Scr = NULL;
UBYTE                 *PubScreenName = NULL;
APTR                   VisualInfo = NULL;
struct Window         *DTConvert_MAINWnd = NULL;
struct Window         *DTConvert_DATATYPEWnd = NULL;
struct Gadget         *DTConvert_MAINGList = NULL;
struct Gadget         *DTConvert_DATATYPEGList = NULL;
UWORD                  DTConvert_MAINZoom[4];
UWORD                  DTConvert_DATATYPEZoom[4];
struct Gadget         *DTConvert_MAINGadgets[8];
struct Gadget         *DTConvert_DATATYPEGadgets[3];
UWORD                  DTConvert_MAINLeft = 10;
UWORD                  DTConvert_MAINTop = 15;
UWORD                  DTConvert_MAINWidth = 476;
UWORD                  DTConvert_MAINHeight = 82;
UWORD                  DTConvert_DATATYPELeft = 47;
UWORD                  DTConvert_DATATYPETop = 31;
UWORD                  DTConvert_DATATYPEWidth = 379;
UWORD                  DTConvert_DATATYPEHeight = 239;
UBYTE                 *DTConvert_MAINWdt = (UBYTE *)"DTConvert";
UBYTE                 *DTConvert_DATATYPEWdt = (UBYTE *)"Select DataType...";
struct TextAttr       *Font, Attr;
UWORD                  FontX, FontY;
UWORD                  OffX, OffY;

UWORD DTConvert_MAINGTypes[] = {
	STRING_KIND,
	TEXT_KIND,
	STRING_KIND,
	BUTTON_KIND,
	BUTTON_KIND,
	BUTTON_KIND,
	BUTTON_KIND,
	BUTTON_KIND
};

UWORD DTConvert_DATATYPEGTypes[] = {
	LISTVIEW_KIND,
	BUTTON_KIND,
	BUTTON_KIND
};

struct NewGadget DTConvert_MAINNGad[] = {
	108, 9, 345, 13, (UBYTE *)"_Source", NULL, GD_SOURCE, PLACETEXT_LEFT, NULL, NULL,
	108, 25, 345, 13, (UBYTE *)"DataType", NULL, GD_DATATYPE, PLACETEXT_LEFT, NULL, NULL,
	108, 41, 345, 13, (UBYTE *)"_Destination", NULL, GD_DESTINATION, PLACETEXT_LEFT, NULL, NULL,
	453, 9, 17, 13, (UBYTE *)"?", NULL, GD_GET_SOURCE, PLACETEXT_IN, NULL, NULL,
	453, 25, 16, 13, (UBYTE *)"?", NULL, GD_GET_DATATYPE, PLACETEXT_IN, NULL, NULL,
	453, 41, 16, 13, (UBYTE *)"?", NULL, GD_GET_DESTINATION, PLACETEXT_IN, NULL, NULL,
	12, 65, 125, 13, (UBYTE *)"_Convert", NULL, GD_CONVERT, PLACETEXT_IN, NULL, NULL,
	344, 65, 125, 13, (UBYTE *)"C_ancel", NULL, GD_CANCEL, PLACETEXT_IN, NULL, NULL
};

struct NewGadget DTConvert_DATATYPENGad[] = {
	10, 14, 363, 200, (UBYTE *)"_DataType", NULL, GD_DATATYPEDT, PLACETEXT_ABOVE, NULL, NULL,
	10, 217, 101, 15, (UBYTE *)"_Ok", NULL, GD_OKDT, PLACETEXT_IN, NULL, NULL,
	272, 217, 101, 15, (UBYTE *)"_Cancel", NULL, GD_CANCELDT, PLACETEXT_IN, NULL, NULL
};

IPTR DTConvert_MAINGTags[] = {
	(STRINGA_ExitHelp), TRUE, (GTST_MaxChars), 1024, (GT_Underscore), '_', (TAG_DONE),
	(GTTX_Border), TRUE, (TAG_DONE),
	(STRINGA_ExitHelp), TRUE, (GTST_MaxChars), 1024, (GT_Underscore), '_', (TAG_DONE),
	(TAG_DONE),
	(TAG_DONE),
	(TAG_DONE),
	(GT_Underscore), '_', (TAG_DONE),
	(GT_Underscore), '_', (TAG_DONE)
};

IPTR DTConvert_DATATYPEGTags[] = {
	(GTLV_ShowSelected), 0, (GT_Underscore), '_', (TAG_DONE),
	(GT_Underscore), '_', (TAG_DONE),
	(GT_Underscore), '_', (TAG_DONE)
};

static UWORD ComputeX( UWORD value )
{
	return(( UWORD )((( FontX * value ) + 4 ) / 8 ));
}

static UWORD ComputeY( UWORD value )
{
	return(( UWORD )((( FontY * value ) + 4 ) / 8 ));
}

static void ComputeFont( UWORD width, UWORD height )
{
      bug("[DTConvert] %s()\n", __func__);
	Font = &Attr;
	Font->ta_Name = (STRPTR)Scr->RastPort.Font->tf_Message.mn_Node.ln_Name;
	Font->ta_YSize = FontY = Scr->RastPort.Font->tf_YSize;
	FontX = Scr->RastPort.Font->tf_XSize;

	OffX = Scr->WBorLeft;
	OffY = Scr->RastPort.TxHeight + Scr->WBorTop + 1;

	if ( width && height ) {
		if (( ComputeX( width ) + OffX + Scr->WBorRight ) > Scr->Width )
			goto UseTopaz;
		if (( ComputeY( height ) + OffY + Scr->WBorBottom ) > Scr->Height )
			goto UseTopaz;
	}
	return;

UseTopaz:
	Font->ta_Name = (STRPTR)"topaz.font";
	FontX = FontY = Font->ta_YSize = 8;
}

int SetupScreen( void )
{
      bug("[DTConvert] %s()\n", __func__);

	if ( ! ( Scr = LockPubScreen( PubScreenName )))
		return( 1L );

	ComputeFont( 0, 0 );

	if ( ! ( VisualInfo = GetVisualInfo( Scr, TAG_DONE )))
		return( 2L );

	return( 0L );
}

void CloseDownScreen( void )
{
      bug("[DTConvert] %s()\n", __func__);
	if ( VisualInfo ) {
		FreeVisualInfo( VisualInfo );
		VisualInfo = NULL;
	}

	if ( Scr        ) {
		UnlockPubScreen( NULL, Scr );
		Scr = NULL;
	}
}

int OpenDTConvert_MAINWindow( void )
{
	struct NewGadget	ng;
	struct Gadget	*g;
	UWORD		lc, tc;
	UWORD		wleft = DTConvert_MAINLeft, wtop = DTConvert_MAINTop, ww, wh;

      bug("[DTConvert] %s()\n", __func__);

	ComputeFont( DTConvert_MAINWidth, DTConvert_MAINHeight );

	ww = ComputeX( DTConvert_MAINWidth );
	wh = ComputeY( DTConvert_MAINHeight );

	if (( wleft + ww + OffX + Scr->WBorRight ) > Scr->Width ) wleft = Scr->Width - ww;
	if (( wtop + wh + OffY + Scr->WBorBottom ) > Scr->Height ) wtop = Scr->Height - wh;

	if ( ! ( g = CreateContext( &DTConvert_MAINGList )))
		return( 1L );

	for( lc = 0, tc = 0; lc < DTConvert_MAIN_CNT; lc++ ) {

		CopyMem((char * )&DTConvert_MAINNGad[ lc ], (char * )&ng, (long)sizeof( struct NewGadget ));

		ng.ng_VisualInfo = VisualInfo;
		ng.ng_TextAttr   = Font;
		ng.ng_LeftEdge   = OffX + ComputeX( ng.ng_LeftEdge );
		ng.ng_TopEdge    = OffY + ComputeY( ng.ng_TopEdge );
		ng.ng_Width      = ComputeX( ng.ng_Width );
		ng.ng_Height     = ComputeY( ng.ng_Height);

		DTConvert_MAINGadgets[ lc ] = g = CreateGadgetA((ULONG)DTConvert_MAINGTypes[ lc ], g, &ng, ( struct TagItem * )&DTConvert_MAINGTags[ tc ] );

		while( DTConvert_MAINGTags[ tc ] ) tc += 2;
		tc++;

		if ( NOT g )
			return( 2L );
	}

	DTConvert_MAINZoom[0] = DTConvert_MAINLeft;
	DTConvert_MAINZoom[1] = DTConvert_MAINTop;
	if ( DTConvert_MAINWdt )
		DTConvert_MAINZoom[2] = TextLength( &Scr->RastPort, (UBYTE *)DTConvert_MAINWdt, (ULONG)strlen((char *)DTConvert_MAINWdt )) + 80;
	else
		DTConvert_MAINZoom[2]  = 80L;
		DTConvert_MAINZoom[3] = Scr->WBorTop + Scr->RastPort.TxHeight + 1;

	if ( ! ( DTConvert_MAINWnd = OpenWindowTags( NULL,
				WA_Left,	wleft,
				WA_Top,		wtop,
				WA_Width,	ww + OffX + Scr->WBorRight,
				WA_Height,	wh + OffY + Scr->WBorBottom,
				WA_IDCMP,	STRINGIDCMP|TEXTIDCMP|BUTTONIDCMP|IDCMP_MENUPICK|IDCMP_CLOSEWINDOW|IDCMP_RAWKEY|IDCMP_VANILLAKEY|IDCMP_MENUHELP|IDCMP_REFRESHWINDOW,
				WA_Flags,	WFLG_DRAGBAR|WFLG_DEPTHGADGET|WFLG_CLOSEGADGET|WFLG_SMART_REFRESH|WFLG_SIMPLE_REFRESH|WFLG_ACTIVATE|WFLG_RMBTRAP,
				WA_Gadgets,	DTConvert_MAINGList,
				WA_Title,	DTConvert_MAINWdt,
				WA_ScreenTitle,	"DTConvert",
				WA_PubScreen,	Scr,
				WA_Zoom,	DTConvert_MAINZoom,
				WA_AutoAdjust,	TRUE,
				WA_PubScreenFallBack,	TRUE,
				TAG_DONE )))
	return( 4L );

	GT_RefreshWindow( DTConvert_MAINWnd, NULL );

	return( 0L );
}

void CloseDTConvert_MAINWindow( void )
{
      bug("[DTConvert] %s()\n", __func__);

	if ( DTConvert_MAINWnd        ) {
		CloseWindow( DTConvert_MAINWnd );
		DTConvert_MAINWnd = NULL;
	}

	if ( DTConvert_MAINGList      ) {
		FreeGadgets( DTConvert_MAINGList );
		DTConvert_MAINGList = NULL;
	}
}

int OpenDTConvert_DATATYPEWindow( void )
{
	struct NewGadget	ng;
	struct Gadget	*g;
	UWORD		lc, tc;
	UWORD		wleft = DTConvert_DATATYPELeft, wtop = DTConvert_DATATYPETop, ww, wh;

      bug("[DTConvert] %s()\n", __func__);

	ComputeFont( DTConvert_DATATYPEWidth, DTConvert_DATATYPEHeight );

	ww = ComputeX( DTConvert_DATATYPEWidth );
	wh = ComputeY( DTConvert_DATATYPEHeight );

	if (( wleft + ww + OffX + Scr->WBorRight ) > Scr->Width ) wleft = Scr->Width - ww;
	if (( wtop + wh + OffY + Scr->WBorBottom ) > Scr->Height ) wtop = Scr->Height - wh;

	if ( ! ( g = CreateContext( &DTConvert_DATATYPEGList )))
		return( 1L );

	for( lc = 0, tc = 0; lc < DTConvert_DATATYPE_CNT; lc++ ) {

		CopyMem((char * )&DTConvert_DATATYPENGad[ lc ], (char * )&ng, (long)sizeof( struct NewGadget ));

		ng.ng_VisualInfo = VisualInfo;
		ng.ng_TextAttr   = Font;
		ng.ng_LeftEdge   = OffX + ComputeX( ng.ng_LeftEdge );
		ng.ng_TopEdge    = OffY + ComputeY( ng.ng_TopEdge );
		ng.ng_Width      = ComputeX( ng.ng_Width );
		ng.ng_Height     = ComputeY( ng.ng_Height);

		DTConvert_DATATYPEGadgets[ lc ] = g = CreateGadgetA((ULONG)DTConvert_DATATYPEGTypes[ lc ], g, &ng, ( struct TagItem * )&DTConvert_DATATYPEGTags[ tc ] );

		while( DTConvert_DATATYPEGTags[ tc ] ) tc += 2;
		tc++;

		if ( NOT g )
			return( 2L );
	}

	DTConvert_DATATYPEZoom[0] = DTConvert_DATATYPELeft;
	DTConvert_DATATYPEZoom[1] = DTConvert_DATATYPETop;
	if ( DTConvert_DATATYPEWdt )
		DTConvert_DATATYPEZoom[2] = TextLength( &Scr->RastPort, (UBYTE *)DTConvert_DATATYPEWdt, (ULONG)strlen((char *)DTConvert_DATATYPEWdt )) + 80;
	else
		DTConvert_DATATYPEZoom[2]  = 80L;
		DTConvert_DATATYPEZoom[3] = Scr->WBorTop + Scr->RastPort.TxHeight + 1;

	if ( ! ( DTConvert_DATATYPEWnd = OpenWindowTags( NULL,
				WA_Left,	wleft,
				WA_Top,		wtop,
				WA_Width,	ww + OffX + Scr->WBorRight,
				WA_Height,	wh + OffY + Scr->WBorBottom,
				WA_IDCMP,	LISTVIEWIDCMP|BUTTONIDCMP|IDCMP_MENUPICK|IDCMP_CLOSEWINDOW|IDCMP_RAWKEY|IDCMP_VANILLAKEY|IDCMP_MENUHELP|IDCMP_REFRESHWINDOW,
				WA_Flags,	WFLG_DRAGBAR|WFLG_DEPTHGADGET|WFLG_CLOSEGADGET|WFLG_SMART_REFRESH|WFLG_SIMPLE_REFRESH|WFLG_ACTIVATE|WFLG_RMBTRAP,
				WA_Gadgets,	DTConvert_DATATYPEGList,
				WA_Title,	DTConvert_DATATYPEWdt,
				WA_ScreenTitle,	"DTConvert",
				WA_PubScreen,	Scr,
				WA_Zoom,	DTConvert_DATATYPEZoom,
				WA_AutoAdjust,	TRUE,
				WA_PubScreenFallBack,	TRUE,
				TAG_DONE )))
	return( 4L );

	GT_RefreshWindow( DTConvert_DATATYPEWnd, NULL );

	return( 0L );
}

void CloseDTConvert_DATATYPEWindow( void )
{
      bug("[DTConvert] %s()\n", __func__);

	if ( DTConvert_DATATYPEWnd        ) {
		CloseWindow( DTConvert_DATATYPEWnd );
		DTConvert_DATATYPEWnd = NULL;
	}

	if ( DTConvert_DATATYPEGList      ) {
		FreeGadgets( DTConvert_DATATYPEGList );
		DTConvert_DATATYPEGList = NULL;
	}
}

