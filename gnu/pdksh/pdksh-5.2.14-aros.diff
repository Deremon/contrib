diff -u -r -N pdksh-5.2.14/c_test.c pdksh-aros/c_test.c
--- pdksh-5.2.14/c_test.c	Wed Jun 30 16:15:31 1999
+++ pdksh-aros/c_test.c	Tue Mar 30 22:14:34 2004
@@ -338,7 +338,9 @@
 	  case TO_FILUID: /* -O */
 		return test_stat(opnd1, &b1) == 0 && b1.st_uid == ksheuid;
 	  case TO_FILGID: /* -G */
-		return test_stat(opnd1, &b1) == 0 && b1.st_gid == getegid();
+/*		return test_stat(opnd1, &b1) == 0 && b1.st_gid == getegid(); */
+/* AROS */
+		return test_stat(opnd1, &b1) == 0 && b1.st_gid == 0;
 	/*
 	 * Binary Operators
 	 */
diff -u -r -N pdksh-5.2.14/env.h pdksh-aros/env.h
--- pdksh-5.2.14/env.h	Wed Dec 31 19:00:00 1969
+++ pdksh-aros/env.h	Tue Mar 30 21:35:33 2004
@@ -0,0 +1,22 @@
+/* struct env_var
+#{
+#    char                *ev_name;
+#    int                 ev_flags;
+#    void                *ev_value;
+#    ev_sethook_t        *ev_sethook;
+#    ev_unsethook_t      *ev_unsethook;
+#    struct env_var      *ev_next, *ev_prev;
+#};
+*/
+/* extern struct env_var   **environ; */
+/*
+#extern struct env_var   *env_getenv(const char *name);
+#extern int              env_setenv(const char *name, int flags,
+#                                   const void *value, ev_sethook_t sethook,
+#                                   ev_unsethook_t unsethook);
+#extern char             *getenv(const char *name); 
+#extern int              setenv(const char *name, const char *value,
+#                               int overwrite);
+#extern int              putenv(const char *string);  
+#extern int              unsetenv(const char *name);
+*/
diff -u -r -N pdksh-5.2.14/eval.c pdksh-aros/eval.c
--- pdksh-5.2.14/eval.c	Tue Jul 13 12:48:39 1999
+++ pdksh-aros/eval.c	Tue Mar 30 22:22:28 2004
@@ -1283,7 +1283,9 @@
 #else /* OS2 */
 		struct passwd *pw;
 
-		pw = getpwnam(name);
+/*		pw = getpwnam(name); */
+/* AROS */
+		pw = "AROS";
 		if (pw == NULL)
 			return NULL;
 		ap->val.s = str_save(pw->pw_dir, APERM);
diff -u -r -N pdksh-5.2.14/ioctl.h pdksh-aros/ioctl.h
--- pdksh-5.2.14/ioctl.h	Wed Dec 31 19:00:00 1969
+++ pdksh-aros/ioctl.h	Tue Mar 30 20:57:10 2004
@@ -0,0 +1,89 @@
+/*	$OpenBSD: ioctl.h,v 1.3 1996/03/03 12:11:50 niklas Exp $	*/
+/*	$NetBSD: ioctl.h,v 1.20 1996/01/30 18:21:47 thorpej Exp $	*/
+
+/*-
+ * Copyright (c) 1982, 1986, 1990, 1993, 1994
+ *	The Regents of the University of California.  All rights reserved.
+ * (c) UNIX System Laboratories, Inc.
+ * All or some portions of this file are derived from material licensed
+ * to the University of California by American Telephone and Telegraph
+ * Co. or Unix System Laboratories, Inc. and are reproduced herein with
+ * the permission of UNIX System Laboratories, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the University of
+ *	California, Berkeley and its contributors.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)ioctl.h	8.6 (Berkeley) 3/28/94
+ */
+
+#ifndef	_SYS_IOCTL_H_
+#define	_SYS_IOCTL_H_
+
+/* #include <sys/ttycom.h> */
+
+/*
+ * Pun for SunOS prior to 3.2.  SunOS 3.2 and later support TIOCGWINSZ
+ * and TIOCSWINSZ (yes, even 3.2-3.5, the fact that it wasn't documented
+ * nonwithstanding).
+ */
+struct ttysize {
+	unsigned short	ts_lines;
+	unsigned short	ts_cols;
+	unsigned short	ts_xxx;
+	unsigned short	ts_yyy;
+};
+#define	TIOCGSIZE	TIOCGWINSZ
+#define	TIOCSSIZE	TIOCSWINSZ
+/*
+#include <sys/ioccom.h>
+
+#include <sys/dkio.h>
+#include <sys/filio.h>
+#include <sys/sockio.h>
+*/
+#ifndef _KERNEL
+
+#include <sys/cdefs.h>
+
+__BEGIN_DECLS
+int	ioctl __P((int, unsigned long, ...));
+__END_DECLS
+#endif /* !_KERNEL */
+#endif /* !_SYS_IOCTL_H_ */
+
+/*
+ * Keep outside _SYS_IOCTL_H_
+ * Compatability with old terminal driver
+ *
+ * Source level -> #define USE_OLD_TTY
+ * Kernel level -> options COMPAT_43 or COMPAT_SUNOS or ...
+ */
+#if defined(USE_OLD_TTY) || defined(COMPAT_43) || defined(COMPAT_SUNOS) || \
+    defined(COMPAT_SVR4) || defined(COMPAT_FREEBSD)
+#include <sys/ioctl_compat.h>
+#endif
diff -u -r -N pdksh-5.2.14/jobs.c pdksh-aros/jobs.c
--- pdksh-5.2.14/jobs.c	Tue Jul 13 12:50:56 1999
+++ pdksh-aros/jobs.c	Tue Mar 30 22:52:20 2004
@@ -500,13 +500,15 @@
 	fill_command(p->command, sizeof(p->command), t);
 
 	/* create child process */
-	forksleep = 1;
+/* No Fork In AROS */
+i = 1;
+/*	forksleep = 1;
 	while ((i = fork()) < 0 && errno == EAGAIN && forksleep < 32) {
-		if (intrsig)	 /* allow user to ^C out... */
+		if (intrsig)
 			break;
 		sleep(forksleep);
 		forksleep <<= 1;
-	}
+	} */
 	if (i < 0) {
 		kill_job(j);
 		remove_job(j, "fork failed");
@@ -1328,7 +1330,9 @@
 #ifdef JOB_SIGS
 		pid = ksh_waitpid(-1, &status, (WNOHANG|WUNTRACED));
 #else /* JOB_SIGS */
-		pid = wait(&status);
+/* AROS */
+/*		pid = wait(&status); */
+		pid = 0;
 #endif /* JOB_SIGS */
 
 		if (pid <= 0)	/* return if would block (0) ... */
diff -u -r -N pdksh-5.2.14/ksh_times.h pdksh-aros/ksh_times.h
--- pdksh-5.2.14/ksh_times.h	Mon Sep  9 14:50:52 1996
+++ pdksh-aros/ksh_times.h	Tue Mar 30 20:32:39 2004
@@ -4,7 +4,7 @@
 /* Needed for clock_t on some systems (ie, NeXT in non-posix mode) */
 #include "ksh_time.h"
 
-#include <sys/times.h>
+#include "times.h"
 
 #ifdef TIMES_BROKEN
 extern clock_t	ksh_times ARGS((struct tms *));
diff -u -r -N pdksh-5.2.14/lex.c pdksh-aros/lex.c
--- pdksh-5.2.14/lex.c	Wed May 12 09:44:53 1999
+++ pdksh-aros/lex.c	Tue Mar 30 21:15:13 2004
@@ -1003,10 +1003,11 @@
 	s->start = s->str = xp;
 
 #ifdef KSH
+/* AROS 
 	if (have_tty && ksh_tmout) {
 		ksh_tmout_state = TMOUT_READING;
 		alarm(ksh_tmout);
-	}
+	} */
 #endif /* KSH */
 #ifdef EDIT
 	if (have_tty && (0
@@ -1066,11 +1067,12 @@
 	 */
 	source = s;
 #ifdef KSH
+/* AROS
 	if (have_tty && ksh_tmout)
 	{
 		ksh_tmout_state = TMOUT_EXECUTING;
 		alarm(0);
-	}
+	} */
 #endif /* KSH */
 	s->start = s->str = Xstring(s->xs, xp);
 	strip_nuls(Xstring(s->xs, xp), Xlength(s->xs, xp));
diff -u -r -N pdksh-5.2.14/main.c pdksh-aros/main.c
--- pdksh-5.2.14/main.c	Tue May 11 09:59:52 1999
+++ pdksh-aros/main.c	Tue Mar 30 22:21:45 2004
@@ -3,13 +3,17 @@
  */
 
 #define	EXTERN				/* define EXTERNs in sh.h */
-
+/* AROS */
+#include "env.h"
+/* End AROS */
 #include "sh.h"
 #include "ksh_stat.h"
 #include "ksh_time.h"
 
-extern char **environ;
-
+/* extern char **environ; */
+/* AROS */
+char *environ;
+/* End AROS */
 /*
  * global data
  */
@@ -235,7 +239,9 @@
 			/* setstr can't fail here */
 			setstr(pwd_v, current_wd, KSH_RETURN_ERROR);
 	}
-	ppid = getppid();
+/*	ppid = getppid(); */
+/* AROS */
+	ppid = 0; 
 	setint(global("PPID"), (long) ppid);
 #ifdef KSH
 	setint(global("RANDOM"), (long) (time((time_t *)0) * kshpid * ppid));
@@ -266,7 +272,9 @@
 	}
 
 	/* Set this before parsing arguments */
-	Flag(FPRIVILEGED) = getuid() != ksheuid || getgid() != getegid();
+/*	Flag(FPRIVILEGED) = getuid() != ksheuid || getgid() != getegid(); */
+/* AROS */
+	Flag(FPRIVILEGED) = 0;
 
 	/* this to note if monitor is set on command line (see below) */
 	Flag(FMONITOR) = 127;
diff -u -r -N pdksh-5.2.14/misc.c pdksh-aros/misc.c
--- pdksh-5.2.14/misc.c	Fri Apr 16 10:50:31 1999
+++ pdksh-aros/misc.c	Tue Mar 30 22:16:14 2004
@@ -309,8 +309,9 @@
 #ifdef OS2
 		;
 #else /* OS2 */
-		setuid(ksheuid = getuid());
-		setgid(getgid());
+/* AROS */
+/*		setuid(ksheuid = getuid());
+		setgid(getgid()); */
 #endif /* OS2 */
 	} else if (f == FPOSIX && newval) {
 #ifdef BRACE_EXPAND
diff -u -r -N pdksh-5.2.14/missing.c pdksh-aros/missing.c
--- pdksh-5.2.14/missing.c	Mon May 24 15:32:27 1999
+++ pdksh-aros/missing.c	Tue Mar 30 22:13:00 2004
@@ -6,6 +6,8 @@
 #include "ksh_stat.h"
 #include "ksh_dir.h"
 
+/* AROS */
+/* #include "timeb.h" */
 
 #ifndef HAVE_MEMSET
 void *
@@ -232,7 +234,8 @@
 	/* Assume times() available, but always returns 0
 	 * (also assumes ftime() available)
 	 */
-	{
+/* AROS */
+/*	{
 		struct timeb tb;
 
 		if (times(tms) == (clock_t) -1)
@@ -242,7 +245,7 @@
 			base_sec = tb.time;
 		rv = (tb.time - base_sec) * CLK_TCK;
 		rv += tb.millitm * CLK_TCK / 1000;
-	}
+	} */
 # endif /* HAVE_GETRUSAGE */
 	return rv;
 }
diff -u -r -N pdksh-5.2.14/proto.h pdksh-aros/proto.h
--- pdksh-5.2.14/proto.h	Tue Jul 13 12:54:51 1999
+++ pdksh-aros/proto.h	Sat Jun 26 13:29:29 2004
@@ -186,7 +186,9 @@
 int	parse_args	ARGS((char **argv, int what, int *setargsp));
 int 	getn		ARGS((const char *as, int *ai));
 int 	bi_getn		ARGS((const char *as, int *ai));
+#ifndef __AROS__ /* we define this thanks anyway */
 char *	strerror	ARGS((int i));
+#endif /* __AROS__ */
 int 	gmatch		ARGS((const char *s, const char *p, int isfile));
 int	has_globbing	ARGS((const char *xp, const char *xpe));
 const unsigned char *pat_scan ARGS((const unsigned char *p,
diff -u -r -N pdksh-5.2.14/sh.h pdksh-aros/sh.h
--- pdksh-5.2.14/sh.h	Thu May 13 13:07:58 1999
+++ pdksh-aros/sh.h	Tue Mar 30 21:55:49 2004
@@ -12,6 +12,9 @@
 # define	ARGS(args)	()	/* K&R declaration */
 #endif
 
+/* AROS */
+#include <process.h>
+extern int spawnvp ARGS((int mode, const char *path, char *const argv[]));
 
 /* Start of common headers */
 
@@ -215,7 +218,9 @@
 					__setostype(1); \
 				} while (0)
 # else /* OS_ISC && _POSIX */
-#  define ksh_execve(p, av, ev, flags)	execve(p, av, ev)
+/* #  define ksh_execve(p, av, ev, flags)	execve(p, av, ev) */
+/* AROS */
+#define ksh_execve(p, av, ev, flags) spawnvp(P_WAIT, p, av)
 # endif /* OS_ISC && _POSIX */
 #endif /* OS2 */
 
@@ -251,7 +256,9 @@
 # if SIZEOF_LONG >= 4
 #  define INT32	long
 # else /* SIZEOF_LONG */
-   #error cannot find 32 bit type...
+/*   #error cannot find 32 bit type... */
+#warning "CHECKME: AROS INT32 is long?"
+#  define INT32	long
 # endif /* SIZEOF_LONG */
 #endif /* SIZEOF_INT */
 
+Tue Mar 30 20:23:24 EST 2004
diff -u -r -N pdksh-5.2.14/stand.h pdksh-aros/stand.h
--- pdksh-5.2.14/stand.h	Wed Dec 31 19:00:00 1969
+++ pdksh-aros/stand.h	Tue Mar 30 21:22:33 2004
@@ -0,0 +1,410 @@
+/*
+ * Copyright (c) 1998 Michael Smith.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD: src/lib/libstand/stand.h,v 1.38 2003/10/26 04:04:12 peter Exp $
+ * From	$NetBSD: stand.h,v 1.22 1997/06/26 19:17:40 drochner Exp $	
+ */
+
+/*-
+ * Copyright (c) 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the University of
+ *	California, Berkeley and its contributors.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)stand.h	8.1 (Berkeley) 6/11/93
+ */
+
+#include <sys/types.h>
+#include <sys/cdefs.h>
+#include <sys/stat.h>
+#include <sys/dirent.h>
+#include <string.h>
+
+#define CHK(fmt, args...)	printf("%s(%d): " fmt "\n", __FUNCTION__, __LINE__ , ##args)
+#define PCHK(fmt, args...)	{printf("%s(%d): " fmt "\n", __FUNCTION__, __LINE__ , ##args); getchar();}
+
+#ifndef NULL
+#define	NULL	0
+#endif
+
+/* Avoid unwanted userlandish components */
+#define _KERNEL
+#include <sys/errno.h>
+#undef _KERNEL
+
+/* special stand error codes */
+#define	EADAPT	(ELAST+1)	/* bad adaptor */
+#define	ECTLR	(ELAST+2)	/* bad controller */
+#define	EUNIT	(ELAST+3)	/* bad unit */
+#define ESLICE	(ELAST+4)	/* bad slice */
+#define	EPART	(ELAST+5)	/* bad partition */
+#define	ERDLAB	(ELAST+6)	/* can't read disk label */
+#define	EUNLAB	(ELAST+7)	/* unlabeled disk */
+#define	EOFFSET	(ELAST+8)	/* relative seek not supported */
+#define	ESALAST	(ELAST+8)	/* */
+
+struct open_file;
+
+/*
+ * This structure is used to define file system operations in a file system
+ * independent way.
+ *
+ * XXX note that filesystem providers should export a pointer to their fs_ops
+ *     struct, so that consumers can reference this and thus include the
+ *     filesystems that they require.
+ */
+struct fs_ops {
+    const char	*fs_name;
+    int		(*fo_open)(const char *path, struct open_file *f);
+    int		(*fo_close)(struct open_file *f);
+    int		(*fo_read)(struct open_file *f, void *buf,
+			   size_t size, size_t *resid);
+    int		(*fo_write)(struct open_file *f, void *buf,
+			    size_t size, size_t *resid);
+    off_t	(*fo_seek)(struct open_file *f, off_t offset, int where);
+    int		(*fo_stat)(struct open_file *f, struct stat *sb);
+    int		(*fo_readdir)(struct open_file *f, struct dirent *d);
+};
+
+/*
+ * libstand-supplied filesystems
+ */
+extern struct fs_ops ufs_fsops;
+extern struct fs_ops tftp_fsops;
+extern struct fs_ops nfs_fsops;
+extern struct fs_ops cd9660_fsops;
+extern struct fs_ops gzipfs_fsops;
+extern struct fs_ops bzipfs_fsops;
+extern struct fs_ops dosfs_fsops;
+extern struct fs_ops ext2fs_fsops;
+extern struct fs_ops splitfs_fsops;
+
+/* where values for lseek(2) */
+#define	SEEK_SET	0	/* set file offset to offset */
+#define	SEEK_CUR	1	/* set file offset to current plus offset */
+#define	SEEK_END	2	/* set file offset to EOF plus offset */
+
+/* 
+ * Device switch
+ */
+struct devsw {
+    const char	dv_name[8];
+    int		dv_type;		/* opaque type constant, arch-dependant */
+    int		(*dv_init)(void);	/* early probe call */
+    int		(*dv_strategy)(void *devdata, int rw, daddr_t blk, size_t size,
+			       char *buf, size_t *rsize);
+    int		(*dv_open)(struct open_file *f, ...);
+    int		(*dv_close)(struct open_file *f);
+    int		(*dv_ioctl)(struct open_file *f, u_long cmd, void *data);
+    void	(*dv_print)(int verbose);	/* print device information */
+    void	(*dv_cleanup)(void);
+};
+
+/*
+ * libstand-supplied device switch
+ */
+extern struct devsw netdev;
+
+extern int errno;
+
+struct open_file {
+    int			f_flags;	/* see F_* below */
+    struct devsw	*f_dev;		/* pointer to device operations */
+    void		*f_devdata;	/* device specific data */
+    struct fs_ops	*f_ops;		/* pointer to file system operations */
+    void		*f_fsdata;	/* file system specific data */
+    off_t		f_offset;	/* current file offset */
+    char		*f_rabuf;	/* readahead buffer pointer */
+    size_t		f_ralen;	/* valid data in readahead buffer */
+    off_t		f_raoffset;	/* consumer offset in readahead buffer */
+#define SOPEN_RASIZE	512
+};
+
+#define	SOPEN_MAX	8
+extern struct open_file files[];
+
+/* f_flags values */
+#define	F_READ		0x0001	/* file opened for reading */
+#define	F_WRITE		0x0002	/* file opened for writing */
+#define	F_RAW		0x0004	/* raw device open - no file system */
+#define F_NODEV		0x0008	/* network open - no device */
+
+#define isascii(c)	(((c) & ~0x7F) == 0)
+
+static __inline int isupper(int c)
+{
+    return c >= 'A' && c <= 'Z';
+}
+
+static __inline int islower(int c)
+{
+    return c >= 'a' && c <= 'z';
+}
+
+static __inline int isspace(int c)
+{
+    return c == ' ' || (c >= 0x9 && c <= 0xd);
+}
+
+static __inline int isdigit(int c)
+{
+    return c >= '0' && c <= '9';
+}
+
+static __inline int isxdigit(int c)
+{
+    return isdigit(c) || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');
+}
+
+static __inline int isalpha(int c)
+{
+    return isupper(c) || islower(c);
+}
+
+static __inline int isalnum(int c)
+{
+    return isalpha(c) || isdigit(c);
+}
+
+static __inline int toupper(int c)
+{
+    return islower(c) ? c - 'a' + 'A' : c;
+}
+
+static __inline int tolower(int c)
+{
+    return isupper(c) ? c - 'A' + 'a' : c;
+}
+
+/* sbrk emulation */
+extern void	setheap(void *base, void *top);
+extern char	*sbrk(int incr);
+
+/* Matt Dillon's zalloc/zmalloc */
+extern void	*malloc(size_t bytes);
+extern void	free(void *ptr);
+/*#define free(p)	{CHK("free %p", p); free(p);} */ /* use for catching guard violations */
+extern void	*calloc(size_t n1, size_t n2);
+extern void	*realloc(void *ptr, size_t size);
+extern void	*reallocf(void *ptr, size_t size);
+extern void	mallocstats(void);
+#ifdef __alpha__
+extern void	free_region(void *start, void *end);
+#endif
+
+/* disklabel support (undocumented, may be junk) */
+struct		disklabel;
+extern char	*getdisklabel(const char *, struct disklabel *);
+
+extern int	printf(const char *fmt, ...) __printflike(1, 2);
+extern void	vprintf(const char *fmt, __va_list);
+extern int	sprintf(char *buf, const char *cfmt, ...) __printflike(2, 3);
+extern void	vsprintf(char *buf, const char *cfmt, __va_list);
+
+extern void	twiddle(void);
+
+extern void	ngets(char *, int);
+#define gets(x)	ngets((x), 0)
+extern int	fgetstr(char *buf, int size, int fd);
+
+extern int	open(const char *, int);
+#define	O_RDONLY	0x0
+#define O_WRONLY	0x1
+#define O_RDWR		0x2
+extern int	close(int);
+extern void	closeall(void);
+extern ssize_t	read(int, void *, size_t);
+extern ssize_t	write(int, void *, size_t);
+extern struct	dirent *readdirfd(int);
+
+extern void	srandom(u_long seed);
+extern u_long	random(void);
+    
+/* imports from stdlib, locally modified */
+extern long	strtol(const char *, char **, int);
+extern char	*optarg;			/* getopt(3) external variables */
+extern int	optind, opterr, optopt, optreset;
+extern int	getopt(int, char * const [], const char *);
+
+/* pager.c */
+extern void	pager_open(void);
+extern void	pager_close(void);
+extern int	pager_output(const char *lines);
+extern int	pager_file(const char *fname);
+
+/* No signal state to preserve */
+#define setjmp	_setjmp
+#define longjmp	_longjmp
+
+/* environment.c */
+#define EV_DYNAMIC	(1<<0)		/* value was dynamically allocated, free if changed/unset */
+#define EV_VOLATILE	(1<<1)		/* value is volatile, make a copy of it */
+#define EV_NOHOOK	(1<<2)		/* don't call hook when setting */
+
+struct env_var;
+typedef char	*(ev_format_t)(struct env_var *ev);
+typedef int	(ev_sethook_t)(struct env_var *ev, int flags,
+		    const void *value);
+typedef int	(ev_unsethook_t)(struct env_var *ev);
+
+struct env_var
+{
+    char		*ev_name;
+    int			ev_flags;
+    void		*ev_value;
+    ev_sethook_t	*ev_sethook;
+    ev_unsethook_t	*ev_unsethook;
+    struct env_var	*ev_next, *ev_prev;
+};
+extern struct env_var	*environ;
+
+extern struct env_var	*env_getenv(const char *name);
+extern int		env_setenv(const char *name, int flags,
+				   const void *value, ev_sethook_t sethook,
+				   ev_unsethook_t unsethook);
+extern char		*getenv(const char *name);
+extern int		setenv(const char *name, const char *value,
+			       int overwrite);
+extern int		putenv(const char *string);
+extern int		unsetenv(const char *name);
+
+extern ev_sethook_t	env_noset;		/* refuse set operation */
+extern ev_unsethook_t	env_nounset;		/* refuse unset operation */
+
+/* BCD conversions (undocumented) */
+extern u_char const	bcd2bin_data[];
+extern u_char const	bin2bcd_data[];
+extern char const	hex2ascii_data[];
+
+#define	bcd2bin(bcd)	(bcd2bin_data[bcd])
+#define	bin2bcd(bin)	(bin2bcd_data[bin])
+#define	hex2ascii(hex)	(hex2ascii_data[hex])
+
+/* min/max (undocumented) */
+static __inline int imax(int a, int b) { return (a > b ? a : b); }
+static __inline int imin(int a, int b) { return (a < b ? a : b); }
+static __inline long lmax(long a, long b) { return (a > b ? a : b); }
+static __inline long lmin(long a, long b) { return (a < b ? a : b); }
+static __inline u_int max(u_int a, u_int b) { return (a > b ? a : b); }
+static __inline u_int min(u_int a, u_int b) { return (a < b ? a : b); }
+static __inline quad_t qmax(quad_t a, quad_t b) { return (a > b ? a : b); }
+static __inline quad_t qmin(quad_t a, quad_t b) { return (a < b ? a : b); }
+static __inline u_long ulmax(u_long a, u_long b) { return (a > b ? a : b); }
+static __inline u_long ulmin(u_long a, u_long b) { return (a < b ? a : b); }
+
+/* swaps (undocumented, useful?) */
+#ifdef __i386__
+extern u_int32_t	bswap32(u_int32_t x);
+extern u_int64_t	bswap64(u_int64_t x);
+#endif
+
+/* null functions for device/filesystem switches (undocumented) */
+extern int	nodev(void);
+extern int	noioctl(struct open_file *, u_long, void *);
+extern void	nullsys(void);
+
+extern int	null_open(const char *path, struct open_file *f);
+extern int	null_close(struct open_file *f);
+extern int	null_read(struct open_file *f, void *buf, size_t size, size_t *resid);
+extern int	null_write(struct open_file *f, void *buf, size_t size, size_t *resid);
+extern off_t	null_seek(struct open_file *f, off_t offset, int where);
+extern int	null_stat(struct open_file *f, struct stat *sb);
+extern int	null_readdir(struct open_file *f, struct dirent *d);
+
+
+/* 
+ * Machine dependent functions and data, must be provided or stubbed by 
+ * the consumer 
+ */
+extern int		getchar(void);
+extern int		ischar(void);
+extern void		putchar(int);
+extern int		devopen(struct open_file *, const char *, const char **);
+extern int		devclose(struct open_file *f);
+extern void		panic(const char *, ...) __dead2;
+extern struct fs_ops	*file_system[];
+extern struct devsw	*devsw[];
+
+/*
+ * Expose byteorder(3) functions.
+ */
+#ifndef _BYTEORDER_PROTOTYPED
+#define	_BYTEORDER_PROTOTYPED
+extern uint32_t		htonl(uint32_t);
+extern uint16_t		htons(uint16_t);
+extern uint32_t		ntohl(uint32_t);
+extern uint16_t		ntohs(uint16_t);
+#endif
+
+#ifndef _BYTEORDER_FUNC_DEFINED
+#define	_BYTEORDER_FUNC_DEFINED
+#define	htonl(x)	__htonl(x)
+#define	htons(x)	__htons(x)
+#define	ntohl(x)	__ntohl(x)
+#define	ntohs(x)	__ntohs(x)
+#endif
+
+void *Malloc(size_t, const char *, int);
+void *Calloc(size_t, size_t, const char *, int);
+void *Realloc(void *, size_t, const char *, int);
+void Free(void *, const char *, int);
+
+#if 1
+#define malloc(x)	Malloc(x, __FILE__, __LINE__)
+#define calloc(x, y)	Calloc(x, y, __FILE__, __LINE__)
+#define free(x)		Free(x, __FILE__, __LINE__)
+#define realloc(x, y)	Realloc(x, y, __FILE__, __LINE__)
+#else
+#define malloc(x)	Malloc(x, NULL, 0)
+#define calloc(x, y)	Calloc(x, y, NULL, 0)
+#define free(x)		Free(x, NULL, 0)
+#define realloc(x, y)	Realloc(x, y, NULL, 0)
+#endif
diff -u -r -N pdksh-5.2.14/timeb.h pdksh-aros/timeb.h
--- pdksh-5.2.14/timeb.h	Wed Dec 31 19:00:00 1969
+++ pdksh-aros/timeb.h	Tue Mar 30 22:02:59 2004
@@ -0,0 +1,61 @@
+/*-
+ * Copyright (c) 1991, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ * (c) UNIX System Laboratories, Inc.
+ * All or some portions of this file are derived from material licensed
+ * to the University of California by American Telephone and Telegraph
+ * Co. or Unix System Laboratories, Inc. and are reproduced herein with
+ * the permission of UNIX System Laboratories, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the University of
+ *	California, Berkeley and its contributors.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)timeb.h	8.2 (Berkeley) 1/21/94
+ * $FreeBSD: src/sys/sys/timeb.h,v 1.8 2002/03/19 20:18:41 alfred Exp $
+ */
+
+#ifndef _SYS_TIMEB_H_
+#define _SYS_TIMEB_H_
+
+/* The ftime(2) system call structure -- deprecated. */
+struct timeb {
+	time_t	time;			/* seconds since the Epoch */
+	unsigned short millitm;		/* + milliseconds since the Epoch */
+	short	timezone;		/* minutes west of CUT */
+	short	dstflag;		/* DST == non-zero */
+};
+
+#ifndef _KERNEL
+#include <sys/cdefs.h>
+
+__BEGIN_DECLS
+int ftime(struct timeb *);
+__END_DECLS
+#endif /* _KERNEL */
+
+#endif
diff -u -r -N pdksh-5.2.14/times.h pdksh-aros/times.h
--- pdksh-5.2.14/times.h	Wed Dec 31 19:00:00 1969
+++ pdksh-aros/times.h	Tue Mar 30 20:25:24 2004
@@ -0,0 +1,66 @@
+/*-
+ * Copyright (c) 1990, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ * (c) UNIX System Laboratories, Inc.
+ * All or some portions of this file are derived from material licensed
+ * to the University of California by American Telephone and Telegraph
+ * Co. or Unix System Laboratories, Inc. and are reproduced herein with
+ * the permission of UNIX System Laboratories, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the University of
+ *	California, Berkeley and its contributors.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)times.h	8.4 (Berkeley) 1/21/94
+ * $FreeBSD: src/sys/sys/times.h,v 1.8 2002/08/21 16:20:01 mike Exp $
+ */
+
+#ifndef	_SYS_TIMES_H_
+#define	_SYS_TIMES_H_
+
+#include <sys/_types.h>
+
+#ifndef _CLOCK_T_DECLARED
+typedef	__clock_t	clock_t;
+#define	_CLOCK_T_DECLARED
+#endif
+
+struct tms {
+	clock_t tms_utime;	/* User CPU time */
+	clock_t tms_stime;	/* System CPU time */
+	clock_t tms_cutime;	/* User CPU time of terminated child procs */
+	clock_t tms_cstime;	/* System CPU time of terminated child procs */
+};
+
+#ifndef _KERNEL
+#include <sys/cdefs.h>
+
+__BEGIN_DECLS
+clock_t	times(struct tms *);
+__END_DECLS
+#endif
+#endif /* !_SYS_TIMES_H_ */
diff -u -r -N pdksh-5.2.14/trap.c pdksh-aros/trap.c
--- pdksh-5.2.14/trap.c	Tue Jan 12 09:35:20 1999
+++ pdksh-aros/trap.c	Tue Mar 30 21:17:20 2004
@@ -68,6 +68,7 @@
 alarm_catcher(sig)
 	int sig;
 {
+/* AROS
 	if (ksh_tmout_state == TMOUT_READING) {
 		int left = alarm(0);
 
@@ -77,7 +78,8 @@
 		} else
 			alarm(left);
 	}
-	return RETSIGVAL;
+	return RETSIGVAL; */
+	return 0;
 }
 #endif /* KSH */
 
diff -u -r -N pdksh-5.2.14/tty.c pdksh-aros/tty.c
--- pdksh-5.2.14/tty.c	Wed Dec 16 14:34:26 1998
+++ pdksh-aros/tty.c	Tue Mar 30 22:49:29 2004
@@ -10,9 +10,12 @@
 	TTY_state *ts;
 {
 	int ret;
-
+/* AROS */
+#define HAVE_TERMIOS_H 
 # ifdef HAVE_TERMIOS_H
-	ret = tcgetattr(fd, ts);
+/* AROS */
+/*	ret = tcgetattr(fd, ts); */
+	ret = 1;
 # else /* HAVE_TERIOS_H */
 #  ifdef HAVE_TERMIO_H
 	ret = ioctl(fd, TCGETA, ts);
@@ -43,7 +46,9 @@
 	int ret = 0;
 
 # ifdef HAVE_TERMIOS_H
-	ret = tcsetattr(fd, TCSADRAIN, ts);
+/* AROS */
+/*	ret = tcsetattr(fd, TCSADRAIN, ts); */
+	ret = 0;
 # else /* HAVE_TERIOS_H */
 #  ifdef HAVE_TERMIO_H
 #   ifndef TCSETAW				/* e.g. Cray-2 */
diff -u -r -N pdksh-5.2.14/tty.h pdksh-aros/tty.h
--- pdksh-5.2.14/tty.h	Tue Oct  8 13:27:21 1996
+++ pdksh-aros/tty.h	Tue Mar 30 21:09:00 2004
@@ -70,8 +70,33 @@
 #   include <sgtty.h>
 #   define TIOCSETN	TIOCSETP
 #  else
-#   include <sys/ioctl.h>
+#   include "ioctl.h"
 #  endif
+/* For AROS from Minix */
+struct sgttyb {
+  char sg_ispeed;  /* input speed */
+  char sg_ospeed;  /* output speed */
+  char sg_erase;  /* erase character */
+  char sg_kill;   /* kill character */
+  int  sg_flags;  /* mode flags */
+};
+
+struct tchars {
+  char t_intrc;   /* SIGINT char */
+  char t_quitc;   /* SIGQUIT char */
+  char t_startc;  /* start output (initially CTRL-Q) */
+  char t_stopc;   /* stop output (initially CTRL-S) */
+  char t_eofc;   /* EOF (initially CTRL-D) */
+  char t_brkc;   /* input delimiter (like nl) */
+};
+
+
+#define  ECHO 0x0008 /* echo input */
+#define  CBREAK 0x0002 /* enable cbreak mode */
+#define TIOCGETP  _IOR(t, 8, struct sgttyb) /* Get/Set parameters */
+#define TCSADRAIN 1
+
+/* End AROS */
 typedef struct {
 	struct sgttyb	sgttyb;
 #  ifdef TIOCGATC
